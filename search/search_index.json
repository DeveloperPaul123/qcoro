{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"QCoro C++ Coroutine Library for Qt5 and Qt6 Overview QCoro is a C++ library that provide set of tools to make use of C++20 coroutines in connection with certain asynchronous Qt actions. Take a look at the example below to see what an amazing thing coroutines are: QNetworkAccessManager networkAccessManager ; // co_await the reply - the coroutine is suspended until the QNetworkReply is finished. // While the coroutine is suspended, *the Qt event loop runs as usual*. const QNetworkReply * reply = co_await networkAccessManager . get ( url ); // Once the reply is finished, your code resumes here as if nothing amazing has just happened ;-) const auto data = reply -> readAll (); This library has only one class and one function that the user must be aware of: the class is QCoro::Task and must be used as a return type for any coroutine that co_await s a Qt type. The function is qCoro() and it provides coroutine-friendly wrappers for Qt types that have multiple asynchronous operations that the user may want to co_await (for example QProcess ). All the other code (basically everything in the QCoro::detail namespace) is here to provide the cogs and gears for the C++ coroutine machinery, making it possible to use Qt types with coroutines. The major benefit of using coroutines with Qt types is that it allows writing asynchronous code as if it were synchronous and, most importantly, while the coroutine is co_await ing, the Qt event loop runs as usual , meaning that your application remains responsive. This is a rather experimental library that I started working on to better understand coroutines in C++. After reading numerous articles and blog posts about coroutines, it still wasn't exactly clear to me how the whole thing works, so I started working on this library to get a better idea about coroutines. Coroutines Coroutines are regular functions, except that they can be suspended and resumed again. When a coroutine is suspended, it returns sort of a promise to the caller and the caller continues executing their code. At some point, the caller can use the newly introduced co_await keyword to wait for the returned promise to be fulfilled. When that happens, the caller is suspended and instead the coroutine is resumed. This allows writing asynchronous code as if it were synchronous, making it much easier to read and understand. That's not all that coroutines can do, you can read more about it in the 'Coroutines' section of this documentation. Supported Compilers This library requires a compiler that supports the Coroutine TS (obviously). Currently GCC, Clang and MSVC are supported. All examples were tested with GCC 10 and Clang 11, although even slightly older versions should work. In both GCC and Clang, coroutine support must be explicitly enabled. GCC To enable coroutines support in GCC, add -fcoroutines to CXX_FLAGS . CMake: set(CMAKE_CXX_STANDARD 20) set(CMAKE_CXX_FLAGS \"${CMAKE_CXX_FLAGS} -fcoroutines\") Alternatively, just use qcoro_enable_coroutines() CMake macro provided by QCoro to set the flags automatically. Clang In Clang coroutines are still considered experimental (unlike in GCC). Coroutines are enabled by adding -fcoroutines-ts to CMAKE_CXX_FLAGS . CMake: set(CMAKE_CXX_STANDARD 20) set(CMAKE_CXX_FLAGS \"${CMAKE_CXX_FLAGS} -fcoroutines-ts\") Alternatively, just use qcoro_enable_coroutines() CMake macro provided by QCoro to set the flags automatically. MSVC Coroutine support in MSVC is enabled automatically by CMake when C++20 standard is specified in CMAKE_CXX_STANDARD : set(CMAKE_CXX_STANDARD 20)","title":"Home"},{"location":"#qcoro","text":"C++ Coroutine Library for Qt5 and Qt6","title":"QCoro"},{"location":"#overview","text":"QCoro is a C++ library that provide set of tools to make use of C++20 coroutines in connection with certain asynchronous Qt actions. Take a look at the example below to see what an amazing thing coroutines are: QNetworkAccessManager networkAccessManager ; // co_await the reply - the coroutine is suspended until the QNetworkReply is finished. // While the coroutine is suspended, *the Qt event loop runs as usual*. const QNetworkReply * reply = co_await networkAccessManager . get ( url ); // Once the reply is finished, your code resumes here as if nothing amazing has just happened ;-) const auto data = reply -> readAll (); This library has only one class and one function that the user must be aware of: the class is QCoro::Task and must be used as a return type for any coroutine that co_await s a Qt type. The function is qCoro() and it provides coroutine-friendly wrappers for Qt types that have multiple asynchronous operations that the user may want to co_await (for example QProcess ). All the other code (basically everything in the QCoro::detail namespace) is here to provide the cogs and gears for the C++ coroutine machinery, making it possible to use Qt types with coroutines. The major benefit of using coroutines with Qt types is that it allows writing asynchronous code as if it were synchronous and, most importantly, while the coroutine is co_await ing, the Qt event loop runs as usual , meaning that your application remains responsive. This is a rather experimental library that I started working on to better understand coroutines in C++. After reading numerous articles and blog posts about coroutines, it still wasn't exactly clear to me how the whole thing works, so I started working on this library to get a better idea about coroutines.","title":"Overview"},{"location":"#coroutines","text":"Coroutines are regular functions, except that they can be suspended and resumed again. When a coroutine is suspended, it returns sort of a promise to the caller and the caller continues executing their code. At some point, the caller can use the newly introduced co_await keyword to wait for the returned promise to be fulfilled. When that happens, the caller is suspended and instead the coroutine is resumed. This allows writing asynchronous code as if it were synchronous, making it much easier to read and understand. That's not all that coroutines can do, you can read more about it in the 'Coroutines' section of this documentation.","title":"Coroutines"},{"location":"#supported-compilers","text":"This library requires a compiler that supports the Coroutine TS (obviously). Currently GCC, Clang and MSVC are supported. All examples were tested with GCC 10 and Clang 11, although even slightly older versions should work. In both GCC and Clang, coroutine support must be explicitly enabled.","title":"Supported Compilers"},{"location":"#gcc","text":"To enable coroutines support in GCC, add -fcoroutines to CXX_FLAGS . CMake: set(CMAKE_CXX_STANDARD 20) set(CMAKE_CXX_FLAGS \"${CMAKE_CXX_FLAGS} -fcoroutines\") Alternatively, just use qcoro_enable_coroutines() CMake macro provided by QCoro to set the flags automatically.","title":"GCC"},{"location":"#clang","text":"In Clang coroutines are still considered experimental (unlike in GCC). Coroutines are enabled by adding -fcoroutines-ts to CMAKE_CXX_FLAGS . CMake: set(CMAKE_CXX_STANDARD 20) set(CMAKE_CXX_FLAGS \"${CMAKE_CXX_FLAGS} -fcoroutines-ts\") Alternatively, just use qcoro_enable_coroutines() CMake macro provided by QCoro to set the flags automatically.","title":"Clang"},{"location":"#msvc","text":"Coroutine support in MSVC is enabled automatically by CMake when C++20 standard is specified in CMAKE_CXX_STANDARD : set(CMAKE_CXX_STANDARD 20)","title":"MSVC"},{"location":"building-and-using/","text":"Building and Using QCoro Building QCoro QCoro uses CMake build system. You can pass following options to the cmake command when building QCoro to customize the build: -DQCORO_BUILD_EXAMPLES - whether to build examples or not ( ON by default). -DQCORO_ENABLE_ASAN - whether to build QCoro with AddressSanitizer ( OFF by default). -DBUILD_SHARED_LIBS - whether to build QCoro as a shared library ( OFF by default). -DBUILD_TESTING - whether to build tests ( ON by default). -DUSE_QT_VERSION - set to 5 or 6 to force a particular version of Qt. When not set the highest available version is used. -DQCORO_WITH_QTDBUS - whether to compile support for QtDBus ( ON by default). -DQCORO_WITH_QTNETWORK - whether to compile support for QtNetwork ( ON by default). -DQCORO_WITH_QTWEBSOCKETS - whether to compile support for QtWebSockets ( ON by default). -DQCORO_DISABLE_DEPRECATED_TASK_H - will not build and install the deprecated task.h header ( OFF by default). mkdir build cd build cmake .. <CMAKE FLAGS> make # This will install QCoro into /usr/local/ prefix, change it by passing -DCMAKE_INSTALL_PREFIX=/usr # to the cmake command above. sudo make install CMake Depending on whether you want to use Qt5 or Qt6 build of QCoro, you should use QCoro5 or QCoro6` in your CMake code, respectively. The example below is assuming Qt6: # Use QCoro5 if you are building for Qt5! find_package ( QCoro6 REQUIRED COMPONENTS Core Network DBus ) # Set necessary compiler flags to enable coroutine support qcoro_enable_coroutines () ... target_link_libraries ( your-target QCoro::Core QCoro::Network QCoro::DBus ) Note the missing Qt version number in the QCoro target namespace: QCoro provides both versioned ( QCoro5 and QCoro6 ) namespaces as well as version-less namespace, which is especially useful for transitioning codebase from Qt5 to Qt6. QMake Using QCoro with QMake projects ( .pro ) is simple: just add the required QCoro modules to the QT variable: QT += QCoroCore QCoroNetwork QCoroDBus # Enable C++20 CONFIG += c+=20 # Enable coroutine support in the compiler QMAKE_CXXFLAGS += -fcoroutines You don't need to worry about Qt5 vs Qt6, qmake will pick up the correct build of QCoro depending on whether you are using QMake for Qt5 or Qt6. Currently it's necessary to manually enable C++20 and coroutine support (unless that's already default in your system/compiler settings).","title":"Building and Using QCoro"},{"location":"building-and-using/#building-and-using-qcoro","text":"","title":"Building and Using QCoro"},{"location":"building-and-using/#building-qcoro","text":"QCoro uses CMake build system. You can pass following options to the cmake command when building QCoro to customize the build: -DQCORO_BUILD_EXAMPLES - whether to build examples or not ( ON by default). -DQCORO_ENABLE_ASAN - whether to build QCoro with AddressSanitizer ( OFF by default). -DBUILD_SHARED_LIBS - whether to build QCoro as a shared library ( OFF by default). -DBUILD_TESTING - whether to build tests ( ON by default). -DUSE_QT_VERSION - set to 5 or 6 to force a particular version of Qt. When not set the highest available version is used. -DQCORO_WITH_QTDBUS - whether to compile support for QtDBus ( ON by default). -DQCORO_WITH_QTNETWORK - whether to compile support for QtNetwork ( ON by default). -DQCORO_WITH_QTWEBSOCKETS - whether to compile support for QtWebSockets ( ON by default). -DQCORO_DISABLE_DEPRECATED_TASK_H - will not build and install the deprecated task.h header ( OFF by default). mkdir build cd build cmake .. <CMAKE FLAGS> make # This will install QCoro into /usr/local/ prefix, change it by passing -DCMAKE_INSTALL_PREFIX=/usr # to the cmake command above. sudo make install","title":"Building QCoro"},{"location":"building-and-using/#cmake","text":"Depending on whether you want to use Qt5 or Qt6 build of QCoro, you should use QCoro5 or QCoro6` in your CMake code, respectively. The example below is assuming Qt6: # Use QCoro5 if you are building for Qt5! find_package ( QCoro6 REQUIRED COMPONENTS Core Network DBus ) # Set necessary compiler flags to enable coroutine support qcoro_enable_coroutines () ... target_link_libraries ( your-target QCoro::Core QCoro::Network QCoro::DBus ) Note the missing Qt version number in the QCoro target namespace: QCoro provides both versioned ( QCoro5 and QCoro6 ) namespaces as well as version-less namespace, which is especially useful for transitioning codebase from Qt5 to Qt6.","title":"CMake"},{"location":"building-and-using/#qmake","text":"Using QCoro with QMake projects ( .pro ) is simple: just add the required QCoro modules to the QT variable: QT += QCoroCore QCoroNetwork QCoroDBus # Enable C++20 CONFIG += c+=20 # Enable coroutine support in the compiler QMAKE_CXXFLAGS += -fcoroutines You don't need to worry about Qt5 vs Qt6, qmake will pick up the correct build of QCoro depending on whether you are using QMake for Qt5 or Qt6. Currently it's necessary to manually enable C++20 and coroutine support (unless that's already default in your system/compiler settings).","title":"QMake"},{"location":"changelog/","text":"Changelog 0.5.1 (2022-04-27) Fix build with GCC>=11.3 ( #57 , #58 ) Fix ODR violation when building with GCC and LTO enabled ( #59 ) 0.5.0 (2022-04-25) Major features: .then() continuation for Task<T> All asynchronous operations now return Task<T> Timeouts for many operations Support for QThread .then() continuation for Task Sometimes it's not possible to co_await a coroutine - usually because you need to integrate with a 3rd party code that is not coroutine-ready. A good example might be implementing QAbstractItemModel , where none of the virtual methods are coroutines and thus it's not possible to use co_await in them. To still make it possible to all coroutines from such code, QCoro::Task<T> now has a new method: .then() , which allows attaching a continuation callback that will be invoked by QCoro when the coroutine represented by the Task finishes. void notACoroutine () { someCoroutineReturningQString (). then ([]( const QString & result ) { // Will be invoked when the someCoroutine() finishes. // The result of the coroutine is passed as an argument to the continuation. }); } The continuation itself might be a coroutine, and the result of the .then() member function is again a Task<R> (where R is the return type of the continuation callback), so it is possible to chain multiple continuations as well as co_await ing the entire chain. All asynchronous operations now return Task<T> Up until now each operation from the QCoro wrapper types returned a special awaitable - for example, QCoroIODevice::read() returned QCoro::detail::QCoroIODevice::ReadOperation . In most cases users of QCoro do not need to concern themselves with that type, since they can still directly co_await the returned awaitable. However, it unnecessarily leaks implementation details of QCoro into public API and it makes it harded to return a coroutine from a non-coroutine function. As of QCoro 0.5.0, all the operations now return Task<T> , which makes the API consistent. As a secondary effect, all the operations can have a chained continuation using the .then() continuation, as described above. Timeout support for many operations Qt doesn't allow specifying timeout for many operations, because they are typically non-blocking. But the timeout makes sense in most QCoro cases, because they are combination of wait + the non-blocking operation. Let's take QIODevice::read() for example: the Qt version doesn't have any timeout, because the call will never block - if there's nothing to read, it simply returns an empty QByteArray . On the other hand, QCoroIODevice::read() is an asynchronous operation, because under to hood, it's a coroutine that asynchronously calls a sequence of device -> waitForReadyRead (); device -> read (); Since QIODevice::waitForReadyRead() takes a timeout argument, it makes sense for QCoroIODevice::read() to also take (an optional) timeout argument. This and many other operations have gained support for timeout. Support for QThread It's been a while since I added a new wrapper for a Qt class, so QCoro 0.5.0 adds wrapper for QThread . It's now possible to co_await thread start and end: std :: unique_ptr < QThread > thread ( QThread :: create ([]() { ... }); ui -> setLabel ( tr ( \"Starting thread...\" ); thread -> start (); co_await qCoro ( thread ) -> waitForStarted (); ui -> setLabel ( tr ( \"Calculating...\" )); co_await qCoro ( thread ) -> waitForFinished (); ui -> setLabel ( tr ( \"Finished!\" )); Full changelog .then() continuation for Task<T> ( #39 ) Fixed namespace scoping ( #45 ) Fixed QCoro::waitFor() getting stuck when coroutine returns synchronously ( #46 ) Fixed -pthread usage in CMake ( #47 ) Produce QMake config files (.pri) for each module ( commit e215616 ) Fix build on platforms where -latomic must be linked explicitly ( #52 ) Return Task<T> from all operations ( #54 ) Add QCoro wrapper for QThread ( commit 832d931 ) Many documentation updates Thanks to everyone who contributed to QCoro! 0.4.0 (2022-01-06) Major highlights in this release: Co-installability of Qt5 and Qt6 builds of QCoro Complete re-work of CMake configuration Support for compiling QCoro with Clang against libstdc++ Co-installability of Qt5 and Qt6 builds of QCoro This change mostly affects packagers of QCoro. It is now possible to install both Qt5 and Qt6 versions of QCoro alongside each other without conflicting files. The shared libraries now contain the Qt version number in their name (e.g. libQCoro6Core.so ) and header files are also located in dedicated subdirectories (e.g. /usr/include/qcoro6/{qcoro,QCoro} ). User of QCoro should not need to do any changes to their codebase. Complete re-work of CMake configuration This change affects users of QCoro, as they will need to adjust CMakeLists.txt of their projects. First, depending on whether they want to use Qt5 or Qt6 version of QCoro, a different package must be used. Additionally, list of QCoro components to use must be specified: find_package(QCoro5 REQUIRED COMPONENTS Core Network DBus) Finally, the target names to use in target_link_libraries have changed as well: QCoro::Core QCoro::Network QCoro::DBus The version-less QCoro namespace can be used regardless of whether using Qt5 or Qt6 build of QCoro. QCoro5 and QCoro6 namespaces are available as well, in case users need to combine both Qt5 and Qt6 versions in their codebase. This change brings QCoro CMake configuration system to the same style and behavior as Qt itself, so it should now be easier to use QCoro, especially when supporting both Qt5 and Qt6. Support for compiling QCoro with Clang against libstdc++ Until now, when the Clang compiler was detected, QCoro forced usage of LLVM's libc++ standard library. Coroutine support requires tight co-operation between the compiler and standard library. Because Clang still considers their coroutine support experimental it expects all coroutine-related types in standard library to be located in std::experimental namespace. In GNU's libstdc++, coroutines are fully supported and thus implemented in the std namespace. This requires a little bit of extra glue, which is now in place. Full changelog QCoro can now be built with Clang against libstdc++ ( #38 , #22 ) Qt5 and Qt6 builds of QCoro are now co-installable ( #36 , #37 ) Fixed early co_return not resuming the caller ( #24 , #35 ) Fixed QProcess example ( #34 ) Test suite has been improved and extended ( #29 , #31 ) Task move assignment operator checks for self-assignment ( #27 ) QCoro can now be built as a subdirectory inside another CMake project ( #25 ) Fixed QCoroCore/qcorocore.h header ( #23 ) DBus is disabled by default on Windows, Mac and Android ( #21 ) Thanks to everyone who contributed to QCoro! 0.3.0 (2021-10-11) Added SOVERSION to shared libraries ( #17 ) Fixed building tests when not building examples ( #19 ) Fixed CI Thanks to everyone who contributed to QCoro 0.3.0! 0.2.0 (2021-09-08) Library modularity The code has been reorganized into three modules (and thus three standalone libraries): QCoroCore, QCoroDBus and QCoroNetwork. QCoroCore contains the elementary QCoro tools ( QCoro::Task , qCoro() wrapper etc.) and coroutine support for some QtCore types. The QCoroDBus module contains coroutine support for types from the QtDBus module and equally the QCoroNetwork module contains coroutine support for types from the QtNetwork module. The latter two modules are also optional, the library can be built without them. It also means that an application that only uses let's say QtNetwork and has no DBus dependency will no longer get QtDBus pulled in through QCoro, as long as it only links against libQCoroCore and libQCoroNetwork . The reorganization will also allow for future support of additional Qt modules. Headers clean up The include headers in QCoro we a bit of a mess and in 0.2.0 they all got a unified form. All public header files now start with qcoro (e.g. qcorotimer.h , qcoronetworkreply.h etc.), and QCoro also provides CamelCase headers now. Thus users should simply do #include <QCoroTimer> if they want coroutine support for QTimer . The reorganization of headers makes QCoro 0.2.0 incompatible with previous versions and any users of QCoro will have to update their #include statements. I'm sorry about this extra hassle, but with this brings much needed sanity into the header organization and naming scheme. Docs update The documentation has been updated to reflect the reorganization as well as some internal changes. It should be easier to understand now and hopefully will make it easier for users to start with QCoro now. Internal API cleanup and code de-duplication Historically, certain types types which can be directly co_await ed with QCoro, for instance QTimer has their coroutine support implemented differently than types that have multiple asynchronous operations and thus have a coroutine-friendly wrapper classes (like QIODevice and it's QCoroIODevice wrapper). In 0.2.0 I have unified the code so that even the coroutine support for simple types like QTimer are implemented through wrapper classes (so there's QCoroTimer now) 0.1.0 (2021-08-15) Initial release QCoro","title":"Changelog"},{"location":"changelog/#changelog","text":"","title":"Changelog"},{"location":"changelog/#051-2022-04-27","text":"Fix build with GCC>=11.3 ( #57 , #58 ) Fix ODR violation when building with GCC and LTO enabled ( #59 )","title":"0.5.1 (2022-04-27)"},{"location":"changelog/#050-2022-04-25","text":"Major features: .then() continuation for Task<T> All asynchronous operations now return Task<T> Timeouts for many operations Support for QThread","title":"0.5.0 (2022-04-25)"},{"location":"changelog/#then-continuation-for-task","text":"Sometimes it's not possible to co_await a coroutine - usually because you need to integrate with a 3rd party code that is not coroutine-ready. A good example might be implementing QAbstractItemModel , where none of the virtual methods are coroutines and thus it's not possible to use co_await in them. To still make it possible to all coroutines from such code, QCoro::Task<T> now has a new method: .then() , which allows attaching a continuation callback that will be invoked by QCoro when the coroutine represented by the Task finishes. void notACoroutine () { someCoroutineReturningQString (). then ([]( const QString & result ) { // Will be invoked when the someCoroutine() finishes. // The result of the coroutine is passed as an argument to the continuation. }); } The continuation itself might be a coroutine, and the result of the .then() member function is again a Task<R> (where R is the return type of the continuation callback), so it is possible to chain multiple continuations as well as co_await ing the entire chain.","title":".then() continuation for Task"},{"location":"changelog/#all-asynchronous-operations-now-return-taskt","text":"Up until now each operation from the QCoro wrapper types returned a special awaitable - for example, QCoroIODevice::read() returned QCoro::detail::QCoroIODevice::ReadOperation . In most cases users of QCoro do not need to concern themselves with that type, since they can still directly co_await the returned awaitable. However, it unnecessarily leaks implementation details of QCoro into public API and it makes it harded to return a coroutine from a non-coroutine function. As of QCoro 0.5.0, all the operations now return Task<T> , which makes the API consistent. As a secondary effect, all the operations can have a chained continuation using the .then() continuation, as described above.","title":"All asynchronous operations now return Task&lt;T&gt;"},{"location":"changelog/#timeout-support-for-many-operations","text":"Qt doesn't allow specifying timeout for many operations, because they are typically non-blocking. But the timeout makes sense in most QCoro cases, because they are combination of wait + the non-blocking operation. Let's take QIODevice::read() for example: the Qt version doesn't have any timeout, because the call will never block - if there's nothing to read, it simply returns an empty QByteArray . On the other hand, QCoroIODevice::read() is an asynchronous operation, because under to hood, it's a coroutine that asynchronously calls a sequence of device -> waitForReadyRead (); device -> read (); Since QIODevice::waitForReadyRead() takes a timeout argument, it makes sense for QCoroIODevice::read() to also take (an optional) timeout argument. This and many other operations have gained support for timeout.","title":"Timeout support for many operations"},{"location":"changelog/#support-for-qthread","text":"It's been a while since I added a new wrapper for a Qt class, so QCoro 0.5.0 adds wrapper for QThread . It's now possible to co_await thread start and end: std :: unique_ptr < QThread > thread ( QThread :: create ([]() { ... }); ui -> setLabel ( tr ( \"Starting thread...\" ); thread -> start (); co_await qCoro ( thread ) -> waitForStarted (); ui -> setLabel ( tr ( \"Calculating...\" )); co_await qCoro ( thread ) -> waitForFinished (); ui -> setLabel ( tr ( \"Finished!\" ));","title":"Support for QThread"},{"location":"changelog/#full-changelog","text":".then() continuation for Task<T> ( #39 ) Fixed namespace scoping ( #45 ) Fixed QCoro::waitFor() getting stuck when coroutine returns synchronously ( #46 ) Fixed -pthread usage in CMake ( #47 ) Produce QMake config files (.pri) for each module ( commit e215616 ) Fix build on platforms where -latomic must be linked explicitly ( #52 ) Return Task<T> from all operations ( #54 ) Add QCoro wrapper for QThread ( commit 832d931 ) Many documentation updates Thanks to everyone who contributed to QCoro!","title":"Full changelog"},{"location":"changelog/#040-2022-01-06","text":"Major highlights in this release: Co-installability of Qt5 and Qt6 builds of QCoro Complete re-work of CMake configuration Support for compiling QCoro with Clang against libstdc++","title":"0.4.0 (2022-01-06)"},{"location":"changelog/#co-installability-of-qt5-and-qt6-builds-of-qcoro","text":"This change mostly affects packagers of QCoro. It is now possible to install both Qt5 and Qt6 versions of QCoro alongside each other without conflicting files. The shared libraries now contain the Qt version number in their name (e.g. libQCoro6Core.so ) and header files are also located in dedicated subdirectories (e.g. /usr/include/qcoro6/{qcoro,QCoro} ). User of QCoro should not need to do any changes to their codebase.","title":"Co-installability of Qt5 and Qt6 builds of QCoro"},{"location":"changelog/#complete-re-work-of-cmake-configuration","text":"This change affects users of QCoro, as they will need to adjust CMakeLists.txt of their projects. First, depending on whether they want to use Qt5 or Qt6 version of QCoro, a different package must be used. Additionally, list of QCoro components to use must be specified: find_package(QCoro5 REQUIRED COMPONENTS Core Network DBus) Finally, the target names to use in target_link_libraries have changed as well: QCoro::Core QCoro::Network QCoro::DBus The version-less QCoro namespace can be used regardless of whether using Qt5 or Qt6 build of QCoro. QCoro5 and QCoro6 namespaces are available as well, in case users need to combine both Qt5 and Qt6 versions in their codebase. This change brings QCoro CMake configuration system to the same style and behavior as Qt itself, so it should now be easier to use QCoro, especially when supporting both Qt5 and Qt6.","title":"Complete re-work of CMake configuration"},{"location":"changelog/#support-for-compiling-qcoro-with-clang-against-libstdc","text":"Until now, when the Clang compiler was detected, QCoro forced usage of LLVM's libc++ standard library. Coroutine support requires tight co-operation between the compiler and standard library. Because Clang still considers their coroutine support experimental it expects all coroutine-related types in standard library to be located in std::experimental namespace. In GNU's libstdc++, coroutines are fully supported and thus implemented in the std namespace. This requires a little bit of extra glue, which is now in place.","title":"Support for compiling QCoro with Clang against libstdc++"},{"location":"changelog/#full-changelog_1","text":"QCoro can now be built with Clang against libstdc++ ( #38 , #22 ) Qt5 and Qt6 builds of QCoro are now co-installable ( #36 , #37 ) Fixed early co_return not resuming the caller ( #24 , #35 ) Fixed QProcess example ( #34 ) Test suite has been improved and extended ( #29 , #31 ) Task move assignment operator checks for self-assignment ( #27 ) QCoro can now be built as a subdirectory inside another CMake project ( #25 ) Fixed QCoroCore/qcorocore.h header ( #23 ) DBus is disabled by default on Windows, Mac and Android ( #21 ) Thanks to everyone who contributed to QCoro!","title":"Full changelog"},{"location":"changelog/#030-2021-10-11","text":"Added SOVERSION to shared libraries ( #17 ) Fixed building tests when not building examples ( #19 ) Fixed CI Thanks to everyone who contributed to QCoro 0.3.0!","title":"0.3.0 (2021-10-11)"},{"location":"changelog/#020-2021-09-08","text":"","title":"0.2.0 (2021-09-08)"},{"location":"changelog/#library-modularity","text":"The code has been reorganized into three modules (and thus three standalone libraries): QCoroCore, QCoroDBus and QCoroNetwork. QCoroCore contains the elementary QCoro tools ( QCoro::Task , qCoro() wrapper etc.) and coroutine support for some QtCore types. The QCoroDBus module contains coroutine support for types from the QtDBus module and equally the QCoroNetwork module contains coroutine support for types from the QtNetwork module. The latter two modules are also optional, the library can be built without them. It also means that an application that only uses let's say QtNetwork and has no DBus dependency will no longer get QtDBus pulled in through QCoro, as long as it only links against libQCoroCore and libQCoroNetwork . The reorganization will also allow for future support of additional Qt modules.","title":"Library modularity"},{"location":"changelog/#headers-clean-up","text":"The include headers in QCoro we a bit of a mess and in 0.2.0 they all got a unified form. All public header files now start with qcoro (e.g. qcorotimer.h , qcoronetworkreply.h etc.), and QCoro also provides CamelCase headers now. Thus users should simply do #include <QCoroTimer> if they want coroutine support for QTimer . The reorganization of headers makes QCoro 0.2.0 incompatible with previous versions and any users of QCoro will have to update their #include statements. I'm sorry about this extra hassle, but with this brings much needed sanity into the header organization and naming scheme.","title":"Headers clean up"},{"location":"changelog/#docs-update","text":"The documentation has been updated to reflect the reorganization as well as some internal changes. It should be easier to understand now and hopefully will make it easier for users to start with QCoro now.","title":"Docs update"},{"location":"changelog/#internal-api-cleanup-and-code-de-duplication","text":"Historically, certain types types which can be directly co_await ed with QCoro, for instance QTimer has their coroutine support implemented differently than types that have multiple asynchronous operations and thus have a coroutine-friendly wrapper classes (like QIODevice and it's QCoroIODevice wrapper). In 0.2.0 I have unified the code so that even the coroutine support for simple types like QTimer are implemented through wrapper classes (so there's QCoroTimer now)","title":"Internal API cleanup and code de-duplication"},{"location":"changelog/#010-2021-08-15","text":"Initial release QCoro","title":"0.1.0 (2021-08-15)"},{"location":"about/license/","text":"License QCoro is published under the MIT License MIT License Copyright (c) 2021 Daniel Vr\u00e1til dvratil@kde.org Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.","title":"License"},{"location":"about/license/#license","text":"QCoro is published under the MIT License","title":"License"},{"location":"about/license/#mit-license","text":"Copyright (c) 2021 Daniel Vr\u00e1til dvratil@kde.org Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.","title":"MIT License"},{"location":"coroutines/coawait/","text":"co_await Explained The following paragraphs try to explain what is a coroutine and what co_await does in some simple way. I don't guarantee that any of this is factically correct. For more gritty (and correct) details, refer to the articles linked at the bottom of this document. Coroutines, simply put, are like normal functions except that they can be suspended (and resumed) in the middle. When a coroutine is suspended, execution returns to the function that has called the coroutine. If that function is also a coroutine and is waiting ( co_await ing) for the current coroutine to finish, then it is suspended as well and the execution returns to the function that has called that coroutine and so on, until a function that is an actual function (not a coroutine) is reached. In case of a regular Qt program, this \"top-level\" non-coroutine function will be the Qt's event loop - which means that while your coroutine, when called from the Qt event loop is suspended, the Qt event loop will continue to run until the coroutine is resumed again. Amongst many other things, this allows you to write asynchronous code as if it were synchronous without blocking the Qt event loop and making your application unresponsive. See the different examples in this document. Now let's look at the co_await keyword. This keyword tells the compiler that this is the point where the coroutine wants to be suspended, until the awaited object (the awaitable ) is ready. Anything type can be awaitable - either because it directly implements the interface needed by the C++ coroutine machinery, or because some external tools (like this library) are provided to wrap that type into something that implements the awaitable interface. The C++ coroutines introduce two additional keywords - co_return and co_yield : From an application programmer point of view, co_return behaves exactly the same as return , except that you cannot use the regular return in coroutines. There are some major differences under the hood, though, which is likely why there's a special keyword for returning from coroutines. co_yield allows a coroutine to produce a result without actually returning. Can be used for writing generators. Currently, this library has no support/usage of co_yield , so I won't go into more details here.","title":"co_await Explained"},{"location":"coroutines/coawait/#co_await-explained","text":"The following paragraphs try to explain what is a coroutine and what co_await does in some simple way. I don't guarantee that any of this is factically correct. For more gritty (and correct) details, refer to the articles linked at the bottom of this document. Coroutines, simply put, are like normal functions except that they can be suspended (and resumed) in the middle. When a coroutine is suspended, execution returns to the function that has called the coroutine. If that function is also a coroutine and is waiting ( co_await ing) for the current coroutine to finish, then it is suspended as well and the execution returns to the function that has called that coroutine and so on, until a function that is an actual function (not a coroutine) is reached. In case of a regular Qt program, this \"top-level\" non-coroutine function will be the Qt's event loop - which means that while your coroutine, when called from the Qt event loop is suspended, the Qt event loop will continue to run until the coroutine is resumed again. Amongst many other things, this allows you to write asynchronous code as if it were synchronous without blocking the Qt event loop and making your application unresponsive. See the different examples in this document. Now let's look at the co_await keyword. This keyword tells the compiler that this is the point where the coroutine wants to be suspended, until the awaited object (the awaitable ) is ready. Anything type can be awaitable - either because it directly implements the interface needed by the C++ coroutine machinery, or because some external tools (like this library) are provided to wrap that type into something that implements the awaitable interface. The C++ coroutines introduce two additional keywords - co_return and co_yield : From an application programmer point of view, co_return behaves exactly the same as return , except that you cannot use the regular return in coroutines. There are some major differences under the hood, though, which is likely why there's a special keyword for returning from coroutines. co_yield allows a coroutine to produce a result without actually returning. Can be used for writing generators. Currently, this library has no support/usage of co_yield , so I won't go into more details here.","title":"co_await Explained"},{"location":"coroutines/qt-vs-coawait/","text":"Qt vs. co_await One of the best examples where coroutines simplify your code is when dealing with asynchronous operations, like network operations. Let's see how a simple HTTP request would be handled in Qt using the signals/slots mechanism: void MyClass::fetchData () { auto * nam = new QNetworkAccessManager ( this ); auto * reply = nam -> get ( QUrl { QStringLiteral ( \"https://.../api/fetch\" )}); QObject :: connect ( reply , & QNetworkReply :: finished , [ reply , nam ]() { const auto data = reply -> readAll (); doSomethingWithData ( data ); reply -> deleteLater (); nam -> deleteLater (); }); } Now let's see how the code looks like if we use coroutines: QCoro :: Task <> MyClass :: fetchData () { QNetworkReply nam ; auto * reply = co_await nam . get ( QUrl { QStringLiteral ( \"https://.../api/fetch\" )}); const auto data = reply -> readAll (); reply -> deleteLater (); doSomethingWithData ( data ); } The magic here is the co_await keyword which has turned our method fetchData() into a coroutine and suspended its execution while the network request was running. When the request finishes, the coroutine is resumed from where it was suspended and continues. And the best part? While the coroutine is suspended, the Qt event loop runs as usual!","title":"Qt vs. co_await"},{"location":"coroutines/qt-vs-coawait/#qt-vs-co_await","text":"One of the best examples where coroutines simplify your code is when dealing with asynchronous operations, like network operations. Let's see how a simple HTTP request would be handled in Qt using the signals/slots mechanism: void MyClass::fetchData () { auto * nam = new QNetworkAccessManager ( this ); auto * reply = nam -> get ( QUrl { QStringLiteral ( \"https://.../api/fetch\" )}); QObject :: connect ( reply , & QNetworkReply :: finished , [ reply , nam ]() { const auto data = reply -> readAll (); doSomethingWithData ( data ); reply -> deleteLater (); nam -> deleteLater (); }); } Now let's see how the code looks like if we use coroutines: QCoro :: Task <> MyClass :: fetchData () { QNetworkReply nam ; auto * reply = co_await nam . get ( QUrl { QStringLiteral ( \"https://.../api/fetch\" )}); const auto data = reply -> readAll (); reply -> deleteLater (); doSomethingWithData ( data ); } The magic here is the co_await keyword which has turned our method fetchData() into a coroutine and suspended its execution while the network request was running. When the request finishes, the coroutine is resumed from where it was suspended and continues. And the best part? While the coroutine is suspended, the Qt event loop runs as usual!","title":"Qt vs. co_await"},{"location":"coroutines/reading/","text":"More reading This library is inspired by Lewis Bakers' cppcoro library, which also served as a guide to implementing the coroutine machinery, alongside his great series on C++ coroutines: Coroutine Theory Understanding Operator co_await Understanding the promise type Understanding Symmetric Transfer I can also recommend numerous articles about C++ coroutines by Raymond Chen on his blog OldNewThink .","title":"Further Reading"},{"location":"coroutines/reading/#more-reading","text":"This library is inspired by Lewis Bakers' cppcoro library, which also served as a guide to implementing the coroutine machinery, alongside his great series on C++ coroutines: Coroutine Theory Understanding Operator co_await Understanding the promise type Understanding Symmetric Transfer I can also recommend numerous articles about C++ coroutines by Raymond Chen on his blog OldNewThink .","title":"More reading"},{"location":"reference/core/","text":"Core Module The Core module contains coroutine-friendly wrapper for QtCore classes. CMake Usage find_package(QCoro6 COMPONENTS Core) ... target_link_libraries(my-target QCoro::Core) QMake Usage QT += QCoroCore","title":"Index"},{"location":"reference/core/#core-module","text":"The Core module contains coroutine-friendly wrapper for QtCore classes.","title":"Core Module"},{"location":"reference/core/#cmake-usage","text":"find_package(QCoro6 COMPONENTS Core) ... target_link_libraries(my-target QCoro::Core)","title":"CMake Usage"},{"location":"reference/core/#qmake-usage","text":"QT += QCoroCore","title":"QMake Usage"},{"location":"reference/core/qfuture/","text":"QFuture Module Core Include #include <QCoroFuture> CMake target_link_libraries ( myapp QCoro :: Core ) QMake QT += QCoroCore QFuture , which represents an asynchronously executed call, doesn't have any operation on its own that could be awaited asynchronously, this is usually done through a helper class called QFutureWatcher . To simplify the API, QCoro allows to directly co_await completion of the running QFuture or use a wrapper class QCoroFuture . To wrap a QFuture into a QCoroFuture , use qCoro() : template < typename T > QCoroFuture qCoro ( const QFuture < T > & future ); waitForFinished() Waits until the future is finished and then returns the result of the future (or nothing, if the future is a QFuture<void> . If the call is already finished or has an error, the coroutine will not suspend and the co_await expression will return immediatelly. This is a coroutine-friendly equivalent to using QFutureWatcher : QFuture < QString > future = QtConcurrent :: run ([]() { ... }); QFutureWatcher < QString > * watcher = new QFutureWatcher < QString > (); QObject :: connect ( watcher , & QFutureWatcher < QString >:: finished , this , [ watcher ]() { watcher -> deleteLater (); const QStrign result = watcher -> result (); ... }); You can also await completion of the future without using QCoroFuture at all by directly co-awaiting the QFuture object: const QString result = co_await QtConcurrent :: run ([]() { ... }); Example #include <QCoroFuture> QCoro :: Task <> runTask () { // Starts a concurrent task and co_awaits on the returned QFuture. While the task is // running, the coroutine is suspended. const QString value = co_await QtConcurrent :: run ([]() { QString result ; ... // do some long-running computation ... return result ; }); // When the future has finished, the coroutine is resumed and the result of the // QFuture is returned and stored in `value`. // ... now do something with the value }","title":"QFuture"},{"location":"reference/core/qfuture/#qfuture","text":"Module Core Include #include <QCoroFuture> CMake target_link_libraries ( myapp QCoro :: Core ) QMake QT += QCoroCore QFuture , which represents an asynchronously executed call, doesn't have any operation on its own that could be awaited asynchronously, this is usually done through a helper class called QFutureWatcher . To simplify the API, QCoro allows to directly co_await completion of the running QFuture or use a wrapper class QCoroFuture . To wrap a QFuture into a QCoroFuture , use qCoro() : template < typename T > QCoroFuture qCoro ( const QFuture < T > & future );","title":"QFuture"},{"location":"reference/core/qfuture/#waitforfinished","text":"Waits until the future is finished and then returns the result of the future (or nothing, if the future is a QFuture<void> . If the call is already finished or has an error, the coroutine will not suspend and the co_await expression will return immediatelly. This is a coroutine-friendly equivalent to using QFutureWatcher : QFuture < QString > future = QtConcurrent :: run ([]() { ... }); QFutureWatcher < QString > * watcher = new QFutureWatcher < QString > (); QObject :: connect ( watcher , & QFutureWatcher < QString >:: finished , this , [ watcher ]() { watcher -> deleteLater (); const QStrign result = watcher -> result (); ... }); You can also await completion of the future without using QCoroFuture at all by directly co-awaiting the QFuture object: const QString result = co_await QtConcurrent :: run ([]() { ... });","title":"waitForFinished()"},{"location":"reference/core/qfuture/#example","text":"#include <QCoroFuture> QCoro :: Task <> runTask () { // Starts a concurrent task and co_awaits on the returned QFuture. While the task is // running, the coroutine is suspended. const QString value = co_await QtConcurrent :: run ([]() { QString result ; ... // do some long-running computation ... return result ; }); // When the future has finished, the coroutine is resumed and the result of the // QFuture is returned and stored in `value`. // ... now do something with the value }","title":"Example"},{"location":"reference/core/qiodevice/","text":"QIODevice Module Core Include #include <QCoroIODevice> CMake target_link_libraries ( myapp QCoro :: Core ) QMake QT += QCoroCore Inherited By QCoroProcess , QCoroAbstractSocket , QCoroLocalSocket , QCoroNetworkReply class QCoroIODevice QIODevice has several different IO operations that can be waited on asynchronously. Since QIODevice itself doesn't provide the abaility to co_await those operations, QCoro provides a wrapper class called QCoroIODevice . To wrap a QIODevice into a QCoroIODevice , use qCoro() : QCoroIODevice qCoro ( QIODevice & ); QCoroIODevice qCoro ( QIODevice * ); Note that Qt provides several subclasses of QIODevice . QCoro provides coroutine-friendly wrappers for some of those types as well (e.g. for QLocalSocket ). This subclass can be passed to qCoro() function as well. Oftentimes the wrapper class will provide some additional features (like co_awaiting establishing connection etc.). You can check whether QCoro supports the QIODevice subclass by checking the list of supported Qt types. readAll() Waits until there are any data to be read from the device (similar to waiting until the device emits QIODevice::readyRead() signal) and then returns all data available in the buffer as a QByteArray . Doesn't suspend the coroutine if there are already data available in the QIODevice or if the QIODevice is not opened for reading. This is the default operation when co_await ing an instance of a QIODevice directly. Thus, it is possible to just do const QByteArray content = co_await device ; instead of const QByteArray content = qCoro ( device ). readAll (); See documentation for QIODevice::readAll() for details. QCoroIODevice::readAll() additionally accepts an optional timeout parameter. If no data become available within the timeout, the coroutine returns an empty QByteArray . If no timeout is specified or if it is set to -1 , the operation will never time out. QCoro :: Task < QByteArray > QCoroIODevice :: readAll (); QCoro :: Task < QByteArray > QCoroIODevice :: readAll ( std :: chrono :: milliseconds timeout ); read() Waits until there are any data to be read from the device (similar to waiting until the device emits QIODevice::readyRead() signal) and then returns up to maxSize bytes as a QByteArray . Doesn't suspend the coroutine if there are already data available in the QIODevice or if the device is not opened for reading. See documentation for QIODevice::read() for details. QCoroIODevice::read() additionally accepts an optional timeout parameter. If no data become available within the timeout, the coroutine returns an empty QByteArray . If no timeout is specified or if it is set to -1 , the operation will never time out. QCoro :: Task < QByteArray > QCoroIODevice :: read ( qint64 maxSize = 0 ); QCoro :: Task < QByteArray > QCoroIODevice :: read ( qint64 maxSize , std :: chrono :: milliseconds timeout ); readLine() Repeatedly waits for data to arrive until it encounters a newline character, end-of-data or until it reads maxSize bytes. Returns the resulting data as QByteArray . See documentation for QIODevice::readLine() for details. QCoroIODevice::readLine() additionally accepts an optional timeout parameter. If no data become available within the timeout, the coroutine returns an empty QByteArray . If no timeout is specified or if it is set to -1 , the operation will never time out. QCoro :: Task < QByteArray > QCoroIODevice :: readLine ( qint64 maxSize = 0 ) QCoro :: Task < QByteArray > QCoroIODevice :: readLine ( qint64 maxSize , std :: chrono :: milliseconds timeout ); waitForReadyRead() Waits for at most timeout_msecs milliseconds for data to become available for reading in the QIODevice . Returns true when the device becomes ready for reading within the given timeout. Returns false if the operation times out, if the device is not opened for reading or in any other state in which the device will never become ready for reading. If the timeout is -1, the operation will never time out. See documentation for QIODevice::waitForReadyRead() for details. QCoro :: Task < bool > QCoroIODevice :: waitForReadyRead ( int timeout_msecs = 30'000 ); QCoro :: Task < bool > QCoroIODevice :: waitForReadyRead ( std :: chrono :: milliseconds timeout ); waitForBytesWritten() Waits for at most timeout_msecs milliseconds for data to be flushed from a buffered QIODevice . Returns std::optional<qint64> , which is empty if the operation has timed out, the device is not opened for writing or is in any other state in which the device will never be able to write any data. When the data are successfully flushed, returns number of bytes written. If the timeout is -1, the operation will never time out. See documentation for QIODevice::waitForBytesWritten() for details. QCoro :: Task < std :: optional < qint64 >> QCoroIODevice :: waitForBytesWritten ( int timeout_msecs = 30'000 ); QCoro :: Task < std :: optional < qint64 >> QCoroIODevice :: waitForBytesWritten ( std :: chrono :: milliseconds timeout ); Examples const QByteArray data = co_await qCoro ( device ). readAll ();","title":"QIODevice"},{"location":"reference/core/qiodevice/#qiodevice","text":"Module Core Include #include <QCoroIODevice> CMake target_link_libraries ( myapp QCoro :: Core ) QMake QT += QCoroCore Inherited By QCoroProcess , QCoroAbstractSocket , QCoroLocalSocket , QCoroNetworkReply class QCoroIODevice QIODevice has several different IO operations that can be waited on asynchronously. Since QIODevice itself doesn't provide the abaility to co_await those operations, QCoro provides a wrapper class called QCoroIODevice . To wrap a QIODevice into a QCoroIODevice , use qCoro() : QCoroIODevice qCoro ( QIODevice & ); QCoroIODevice qCoro ( QIODevice * ); Note that Qt provides several subclasses of QIODevice . QCoro provides coroutine-friendly wrappers for some of those types as well (e.g. for QLocalSocket ). This subclass can be passed to qCoro() function as well. Oftentimes the wrapper class will provide some additional features (like co_awaiting establishing connection etc.). You can check whether QCoro supports the QIODevice subclass by checking the list of supported Qt types.","title":"QIODevice"},{"location":"reference/core/qiodevice/#readall","text":"Waits until there are any data to be read from the device (similar to waiting until the device emits QIODevice::readyRead() signal) and then returns all data available in the buffer as a QByteArray . Doesn't suspend the coroutine if there are already data available in the QIODevice or if the QIODevice is not opened for reading. This is the default operation when co_await ing an instance of a QIODevice directly. Thus, it is possible to just do const QByteArray content = co_await device ; instead of const QByteArray content = qCoro ( device ). readAll (); See documentation for QIODevice::readAll() for details. QCoroIODevice::readAll() additionally accepts an optional timeout parameter. If no data become available within the timeout, the coroutine returns an empty QByteArray . If no timeout is specified or if it is set to -1 , the operation will never time out. QCoro :: Task < QByteArray > QCoroIODevice :: readAll (); QCoro :: Task < QByteArray > QCoroIODevice :: readAll ( std :: chrono :: milliseconds timeout );","title":"readAll()"},{"location":"reference/core/qiodevice/#read","text":"Waits until there are any data to be read from the device (similar to waiting until the device emits QIODevice::readyRead() signal) and then returns up to maxSize bytes as a QByteArray . Doesn't suspend the coroutine if there are already data available in the QIODevice or if the device is not opened for reading. See documentation for QIODevice::read() for details. QCoroIODevice::read() additionally accepts an optional timeout parameter. If no data become available within the timeout, the coroutine returns an empty QByteArray . If no timeout is specified or if it is set to -1 , the operation will never time out. QCoro :: Task < QByteArray > QCoroIODevice :: read ( qint64 maxSize = 0 ); QCoro :: Task < QByteArray > QCoroIODevice :: read ( qint64 maxSize , std :: chrono :: milliseconds timeout );","title":"read()"},{"location":"reference/core/qiodevice/#readline","text":"Repeatedly waits for data to arrive until it encounters a newline character, end-of-data or until it reads maxSize bytes. Returns the resulting data as QByteArray . See documentation for QIODevice::readLine() for details. QCoroIODevice::readLine() additionally accepts an optional timeout parameter. If no data become available within the timeout, the coroutine returns an empty QByteArray . If no timeout is specified or if it is set to -1 , the operation will never time out. QCoro :: Task < QByteArray > QCoroIODevice :: readLine ( qint64 maxSize = 0 ) QCoro :: Task < QByteArray > QCoroIODevice :: readLine ( qint64 maxSize , std :: chrono :: milliseconds timeout );","title":"readLine()"},{"location":"reference/core/qiodevice/#waitforreadyread","text":"Waits for at most timeout_msecs milliseconds for data to become available for reading in the QIODevice . Returns true when the device becomes ready for reading within the given timeout. Returns false if the operation times out, if the device is not opened for reading or in any other state in which the device will never become ready for reading. If the timeout is -1, the operation will never time out. See documentation for QIODevice::waitForReadyRead() for details. QCoro :: Task < bool > QCoroIODevice :: waitForReadyRead ( int timeout_msecs = 30'000 ); QCoro :: Task < bool > QCoroIODevice :: waitForReadyRead ( std :: chrono :: milliseconds timeout );","title":"waitForReadyRead()"},{"location":"reference/core/qiodevice/#waitforbyteswritten","text":"Waits for at most timeout_msecs milliseconds for data to be flushed from a buffered QIODevice . Returns std::optional<qint64> , which is empty if the operation has timed out, the device is not opened for writing or is in any other state in which the device will never be able to write any data. When the data are successfully flushed, returns number of bytes written. If the timeout is -1, the operation will never time out. See documentation for QIODevice::waitForBytesWritten() for details. QCoro :: Task < std :: optional < qint64 >> QCoroIODevice :: waitForBytesWritten ( int timeout_msecs = 30'000 ); QCoro :: Task < std :: optional < qint64 >> QCoroIODevice :: waitForBytesWritten ( std :: chrono :: milliseconds timeout );","title":"waitForBytesWritten()"},{"location":"reference/core/qiodevice/#examples","text":"const QByteArray data = co_await qCoro ( device ). readAll ();","title":"Examples"},{"location":"reference/core/qprocess/","text":"QProcess Module Core Include #include <QCoroProcess> CMake target_link_libraries ( myapp QCoro :: Core ) QMake QT += QCoroCore Inherits QCoroIODevice QProcess normally has two features to wait for asynchronously: the process to start and to finish. Since QProcess itself doesn't provide the ability to co_await those operations, QCoro provides a wrapper class QCoroProcess . To wrap a QProcess object into the QCoroProcess wrapper, use qCoro() : QCoroProcess qCoro ( QProcess & ); QCoroProcess qCoro ( QProcess * ); Same as QProcess is a subclass of QIODevice , QCoroProcess subclasses QCoroIODevice , so it also provides the awaitable interface for selected QIODevice functions. See QCoroIODevice documentation for details. waitForStarted() Waits for the process to be started or until it times out. Returns bool indicating whether the process has started successfuly ( true ) or timed out ( false ). See documentation for QProcess::waitForStarted() for details. QCoro :: Task < bool > QCoroProcess :: waitForStarted ( int timeout = 30'000 ); QCoro :: Task < bool > QCoroProcess :: waitForStarted ( std :: chrono :: milliseconds timeout ); waitForFinished() Waits for the process to finish or until it times out. Returns bool indicating whether the process has finished successfuly ( true ) or timed out ( false ). See documentation for [ QProcess::waitForFinished() ][qtdoc-qprocess-waitForFinished] for details. QCoro :: Task < bool > QCoroProcess :: waitForFinishedint timeout = 30'000 ); QCoro :: Task < bool > QCoroProcess :: waitForFinished ( std :: chrono :: milliseconds timeout ); start() QCoroProcess provides an additional method called start() which is equivalent to calling QProcess::start() followed by QCoroProcess::waitForStarted() . This operation is co_awaitable as well. See the documentation for QProcess::start() and QProcess::waitForStarted() for details.o Returns true when the process has successfully started, false otherwise. QCoro :: Task < bool > QCoroProcess :: start ( QIODevice :: OpenMode openMode = QIODevice :: ReadOnly , std :: chrono :: milliseconds timeout = std :: chrono :: seconds ( 30 )); QCoro :: Task < bool > QCoroProcess :: start ( const QString & program , const QStringList & arguments , QIODevice :: OpenMode openMode = QIODevice :: ReadOnly , std :: chrono :: milliseconds timeout = std :: chrono :: seconds ( 30 )); Examples #include <QCoroProcess> QCoro :: Task < QByteArray > listDir ( const QString & dirPath ) { QProcess basicProcess ; auto process = qCoro ( basicProcess ); qDebug () << \"Starting ls...\" ; co_await process . start ( QStringLiteral ( \"/bin/ls\" ), { dirPath }); qDebug () << \"Ls started, reading directory...\" ; co_await process . waitForFinished (); qDebug () << \"Done\" ; return basicProcess . readAll (); }","title":"QProcess"},{"location":"reference/core/qprocess/#qprocess","text":"Module Core Include #include <QCoroProcess> CMake target_link_libraries ( myapp QCoro :: Core ) QMake QT += QCoroCore Inherits QCoroIODevice QProcess normally has two features to wait for asynchronously: the process to start and to finish. Since QProcess itself doesn't provide the ability to co_await those operations, QCoro provides a wrapper class QCoroProcess . To wrap a QProcess object into the QCoroProcess wrapper, use qCoro() : QCoroProcess qCoro ( QProcess & ); QCoroProcess qCoro ( QProcess * ); Same as QProcess is a subclass of QIODevice , QCoroProcess subclasses QCoroIODevice , so it also provides the awaitable interface for selected QIODevice functions. See QCoroIODevice documentation for details.","title":"QProcess"},{"location":"reference/core/qprocess/#waitforstarted","text":"Waits for the process to be started or until it times out. Returns bool indicating whether the process has started successfuly ( true ) or timed out ( false ). See documentation for QProcess::waitForStarted() for details. QCoro :: Task < bool > QCoroProcess :: waitForStarted ( int timeout = 30'000 ); QCoro :: Task < bool > QCoroProcess :: waitForStarted ( std :: chrono :: milliseconds timeout );","title":"waitForStarted()"},{"location":"reference/core/qprocess/#waitforfinished","text":"Waits for the process to finish or until it times out. Returns bool indicating whether the process has finished successfuly ( true ) or timed out ( false ). See documentation for [ QProcess::waitForFinished() ][qtdoc-qprocess-waitForFinished] for details. QCoro :: Task < bool > QCoroProcess :: waitForFinishedint timeout = 30'000 ); QCoro :: Task < bool > QCoroProcess :: waitForFinished ( std :: chrono :: milliseconds timeout );","title":"waitForFinished()"},{"location":"reference/core/qprocess/#start","text":"QCoroProcess provides an additional method called start() which is equivalent to calling QProcess::start() followed by QCoroProcess::waitForStarted() . This operation is co_awaitable as well. See the documentation for QProcess::start() and QProcess::waitForStarted() for details.o Returns true when the process has successfully started, false otherwise. QCoro :: Task < bool > QCoroProcess :: start ( QIODevice :: OpenMode openMode = QIODevice :: ReadOnly , std :: chrono :: milliseconds timeout = std :: chrono :: seconds ( 30 )); QCoro :: Task < bool > QCoroProcess :: start ( const QString & program , const QStringList & arguments , QIODevice :: OpenMode openMode = QIODevice :: ReadOnly , std :: chrono :: milliseconds timeout = std :: chrono :: seconds ( 30 ));","title":"start()"},{"location":"reference/core/qprocess/#examples","text":"#include <QCoroProcess> QCoro :: Task < QByteArray > listDir ( const QString & dirPath ) { QProcess basicProcess ; auto process = qCoro ( basicProcess ); qDebug () << \"Starting ls...\" ; co_await process . start ( QStringLiteral ( \"/bin/ls\" ), { dirPath }); qDebug () << \"Ls started, reading directory...\" ; co_await process . waitForFinished (); qDebug () << \"Done\" ; return basicProcess . readAll (); }","title":"Examples"},{"location":"reference/core/qthread/","text":"QThread Module Core Include #include <QCoroThread> CMake target_link_libraries ( myapp QCoro :: Core ) QMake QT += QCoroCore QThread has two events: started and finished . QCoro provides a coroutine-friendly wrapper for QThread - QCoroThread , which allows co_await ing those events. To wrap a QThread object into the QCoroThread wrapper, use qCoro() : QCoroThread qCoro ( QThread & ); QCoroThread qCoro ( QThread * ); waitForStarted() Waits for the thread to start. Returns true if the thread is already running or when the thread starts within the specified timeout. If the thread has already finished or fails to start within the specified timeout, the coroutine will return false . If the timeout is set to -1, the operation will never time out. See documentation for [ QThread::started() ][qtdoc-qthread-started] for details. QCoro :: Task < bool > QCoroThread :: waitForStarted ( std :: chrono :: milliseconds timeout ); waitForFinished() Waits for the Waits for the process to finish or until it times out. Returns bool indicating whether the process has finished successfuly ( true ) or timed out ( false ). thread to finish. Returns true if the thread has already finished or if it finishes within the specified timeout. If the thread has not started yet or fails to stop within the specified timeout the coroutine will return false . If the timeout is set to -1, the operation will never time out. See documentation for [ QThread::finished() ][qtdoc-qthread-finished] for details. QCoro :: Task < bool > QCoroThread :: waitForFinished ( std :: chrono :: milliseconds timeout ); Examples #include <QCoroThread> #include <QThread> #include <memory> QCoro :: Task < void > MainWindow :: processData ( const QVector < qint64 > & data ) { std :: unique_ptr < QThread > thread ( QThread :: create ([ data ]() { // Perform some intesive calculation })); thread -> start (); ui -> setState ( tr ( \"Processing is starting...\" )); co_await qCoro ( thread . get ()). waitForStarted (); ui -> setState ( tr ( \"Processing data...\" )); co_await qCoro ( thread . get ()). waitForFinished (); ui -> setState ( tr ( \"Processing done.\" )); }","title":"QThread"},{"location":"reference/core/qthread/#qthread","text":"Module Core Include #include <QCoroThread> CMake target_link_libraries ( myapp QCoro :: Core ) QMake QT += QCoroCore QThread has two events: started and finished . QCoro provides a coroutine-friendly wrapper for QThread - QCoroThread , which allows co_await ing those events. To wrap a QThread object into the QCoroThread wrapper, use qCoro() : QCoroThread qCoro ( QThread & ); QCoroThread qCoro ( QThread * );","title":"QThread"},{"location":"reference/core/qthread/#waitforstarted","text":"Waits for the thread to start. Returns true if the thread is already running or when the thread starts within the specified timeout. If the thread has already finished or fails to start within the specified timeout, the coroutine will return false . If the timeout is set to -1, the operation will never time out. See documentation for [ QThread::started() ][qtdoc-qthread-started] for details. QCoro :: Task < bool > QCoroThread :: waitForStarted ( std :: chrono :: milliseconds timeout );","title":"waitForStarted()"},{"location":"reference/core/qthread/#waitforfinished","text":"Waits for the Waits for the process to finish or until it times out. Returns bool indicating whether the process has finished successfuly ( true ) or timed out ( false ). thread to finish. Returns true if the thread has already finished or if it finishes within the specified timeout. If the thread has not started yet or fails to stop within the specified timeout the coroutine will return false . If the timeout is set to -1, the operation will never time out. See documentation for [ QThread::finished() ][qtdoc-qthread-finished] for details. QCoro :: Task < bool > QCoroThread :: waitForFinished ( std :: chrono :: milliseconds timeout );","title":"waitForFinished()"},{"location":"reference/core/qthread/#examples","text":"#include <QCoroThread> #include <QThread> #include <memory> QCoro :: Task < void > MainWindow :: processData ( const QVector < qint64 > & data ) { std :: unique_ptr < QThread > thread ( QThread :: create ([ data ]() { // Perform some intesive calculation })); thread -> start (); ui -> setState ( tr ( \"Processing is starting...\" )); co_await qCoro ( thread . get ()). waitForStarted (); ui -> setState ( tr ( \"Processing data...\" )); co_await qCoro ( thread . get ()). waitForFinished (); ui -> setState ( tr ( \"Processing done.\" )); }","title":"Examples"},{"location":"reference/core/qtimer/","text":"QTimer Module Core Include #include <QCoroTimer> CMake target_link_libraries ( myapp QCoro :: Core ) QMake QT += QCoroCore QTimer timer ; timer . start ( 1 s ); co_await timer ; The QCoro frameworks allows co_await ing on QTimer object. The co-awaiting coroutine is suspended, until the timer finishes, that is until QTimer::timeout() signal is emitted. The timer must be active. If the timer is not active (not started yet or already finished) the co_await expression will return immediately. To make it work, include QCoroTimer in your implementation. #include <QCoroTimer> #include <chrono> using namespace std :: chrono_literals ; QCoro :: Task <> MyClass :: pretendWork () { // Creates and starts a QTimer that will tick every second QTimer timer ; timer . setInterval ( 1 s ); timer . start (); for ( int i = 1 ; i <= 100 ; ++ i ) { // Wait for the timer to tick co_await timer ; // Update the progress bar value mProgressBar -> setValue ( i ); // And repeat... } // ... until the for loop finishes. }","title":"QTimer"},{"location":"reference/core/qtimer/#qtimer","text":"Module Core Include #include <QCoroTimer> CMake target_link_libraries ( myapp QCoro :: Core ) QMake QT += QCoroCore QTimer timer ; timer . start ( 1 s ); co_await timer ; The QCoro frameworks allows co_await ing on QTimer object. The co-awaiting coroutine is suspended, until the timer finishes, that is until QTimer::timeout() signal is emitted. The timer must be active. If the timer is not active (not started yet or already finished) the co_await expression will return immediately. To make it work, include QCoroTimer in your implementation. #include <QCoroTimer> #include <chrono> using namespace std :: chrono_literals ; QCoro :: Task <> MyClass :: pretendWork () { // Creates and starts a QTimer that will tick every second QTimer timer ; timer . setInterval ( 1 s ); timer . start (); for ( int i = 1 ; i <= 100 ; ++ i ) { // Wait for the timer to tick co_await timer ; // Update the progress bar value mProgressBar -> setValue ( i ); // And repeat... } // ... until the for loop finishes. }","title":"QTimer"},{"location":"reference/core/signals/","text":"Module Core Include #include <QCoroSignal> CMake target_link_libraries ( myapp QCoro :: Core ) QMake QT += QCoroCore Signals It's possible to co_await a single signal emission through a special overload of the qCoro() function. The below function returns an awaitable that will suspend the current coroutine until the specified signal is emitted. Task < SignalResult > qCoro ( QObject * obj , QtSignalPtr ptr ); The arguments are a pointer to a QObject-derived object and a pointer to a the object's signal to connect to. Note that if the object is destroyed while being co_await ed, the coroutine will never be resumed. The returned awaitable produces the signal's arguments. That is, if the signal has no arguments, the result of the awaitable will be void . If the signal has exactly one argument, then the awaitable produces the value of the argument. If the signal has more than one arguments, then the result of the awaitable is a std::tuple with all the arguments. Example: // void signal co_await qCoro(timer, &QTimer::timeout); // single-argument signal const QUrl url = co_await qCoro(reply, &QNetworkReply::redirected); // multi-argument signal, captured using structured bindings const auto [exitCode, exitStatus] = co_await qCoro(process, &QProcess::finished); Task < std :: optional < SignalResult >> qCoro ( QObject * obj , QtSignalPtr ptr , std :: chrono :: milliseconds timeout ); An overload that behaves similar to the two-argument overload, but takes an additional timeout argument. If the signal is not emitted within the specified timeout, the returned awaitable produces an empty std::optional . Otherwise the return type behaves the same way as the two-argument overload. QCoroSignalListener A helper function that creates an AsyncGenerator which yields a value whenever the signal is emitted. QCoro :: AsyncGenerator < SignalArgs > qCoroSignalListener ( QObject * obj , QtSignalPtr ptr , std :: chrono :: milliseconds timeout ); The function takes up to three arguments, the obj and ptr are a QObject-derived object and a pointer to a signal member function to connect to. The third timeout argument is optional. When the timeout is set, the generator will end if the signal is not emitted within the specified timeout. When not set, or set to -1, the generator will never terminate on its own, even if the obj QObject is destroyed! The generator produces all signal emissions, even those that ocur in between the generator being co_await ed. In the example below, even when the QNetworkReply::downloadProgress() signal is emitted while asynchronously processing something in the middle of the while loop body, the emission will not be lost. It will be enqueued, and returned synchronously with the next co_await ++it call. auto listener = qCoroSignalListener ( networkReply , & QNetworkReply :: downloadProgress ); auto it = co_await listener . begin (); // waits for first emission while ( it != listener . end () && networkReply -> isRunning ()) { const auto [ received , total ] = * it ; // do something with results //... if ( received == total || networkReply -> isFinished ()) { break ; } co_await ++ it ; // waits for next signal emission } Alternatively, it's possible to use QCORO_FOREACH to look over the generator: QCORO_FOREACH ( const auto [ received , total ], qCoroSignalListener ( reply , & QNetworkReply :: downloadProgress )) { // do something with `received` and `total` values if ( received == total || reply -> isFinished ()) { break ; } } Listener doesn't stop listening until destroyed. Keep in mind that the listener generator will keep listening and collecting the signal emissions until it is destroyed, even if you are no longer actively iterating over the generator. It is recommended that you destroy the generator as soon as possible when you no longer need it.","title":"Qt Signals"},{"location":"reference/core/signals/#signals","text":"It's possible to co_await a single signal emission through a special overload of the qCoro() function. The below function returns an awaitable that will suspend the current coroutine until the specified signal is emitted. Task < SignalResult > qCoro ( QObject * obj , QtSignalPtr ptr ); The arguments are a pointer to a QObject-derived object and a pointer to a the object's signal to connect to. Note that if the object is destroyed while being co_await ed, the coroutine will never be resumed. The returned awaitable produces the signal's arguments. That is, if the signal has no arguments, the result of the awaitable will be void . If the signal has exactly one argument, then the awaitable produces the value of the argument. If the signal has more than one arguments, then the result of the awaitable is a std::tuple with all the arguments. Example: // void signal co_await qCoro(timer, &QTimer::timeout); // single-argument signal const QUrl url = co_await qCoro(reply, &QNetworkReply::redirected); // multi-argument signal, captured using structured bindings const auto [exitCode, exitStatus] = co_await qCoro(process, &QProcess::finished); Task < std :: optional < SignalResult >> qCoro ( QObject * obj , QtSignalPtr ptr , std :: chrono :: milliseconds timeout ); An overload that behaves similar to the two-argument overload, but takes an additional timeout argument. If the signal is not emitted within the specified timeout, the returned awaitable produces an empty std::optional . Otherwise the return type behaves the same way as the two-argument overload.","title":"Signals"},{"location":"reference/core/signals/#qcorosignallistener","text":"A helper function that creates an AsyncGenerator which yields a value whenever the signal is emitted. QCoro :: AsyncGenerator < SignalArgs > qCoroSignalListener ( QObject * obj , QtSignalPtr ptr , std :: chrono :: milliseconds timeout ); The function takes up to three arguments, the obj and ptr are a QObject-derived object and a pointer to a signal member function to connect to. The third timeout argument is optional. When the timeout is set, the generator will end if the signal is not emitted within the specified timeout. When not set, or set to -1, the generator will never terminate on its own, even if the obj QObject is destroyed! The generator produces all signal emissions, even those that ocur in between the generator being co_await ed. In the example below, even when the QNetworkReply::downloadProgress() signal is emitted while asynchronously processing something in the middle of the while loop body, the emission will not be lost. It will be enqueued, and returned synchronously with the next co_await ++it call. auto listener = qCoroSignalListener ( networkReply , & QNetworkReply :: downloadProgress ); auto it = co_await listener . begin (); // waits for first emission while ( it != listener . end () && networkReply -> isRunning ()) { const auto [ received , total ] = * it ; // do something with results //... if ( received == total || networkReply -> isFinished ()) { break ; } co_await ++ it ; // waits for next signal emission } Alternatively, it's possible to use QCORO_FOREACH to look over the generator: QCORO_FOREACH ( const auto [ received , total ], qCoroSignalListener ( reply , & QNetworkReply :: downloadProgress )) { // do something with `received` and `total` values if ( received == total || reply -> isFinished ()) { break ; } } Listener doesn't stop listening until destroyed. Keep in mind that the listener generator will keep listening and collecting the signal emissions until it is destroyed, even if you are no longer actively iterating over the generator. It is recommended that you destroy the generator as soon as possible when you no longer need it.","title":"QCoroSignalListener"},{"location":"reference/coro/","text":"Coro module The Coro module contains the fundamental coroutine types - the QCoro::Task<T> for asynchronous coroutines, QCoro::Generator<T> for synchronous generators and QCoro::AsyncGenerator<T> for asynchronous generators. Another useful bit of the Coro module is the qCoro() wrapper function that wraps native Qt types into a coroutine-friendly versions supported by QCoro (check the Core , Network and DBus modules of QCoro to see which Qt types are currently supported by QCoro). If you don't want to use any of the Qt types supported by QCoro in your code, but you still want to use C++ coroutines with QCoro, you can simply just link against QCoro::Coro target in your CMakeLists.txt. This will give you all you need to start implementing custom coroutine-native types with Qt and QCoro.","title":"Index"},{"location":"reference/coro/#coro-module","text":"The Coro module contains the fundamental coroutine types - the QCoro::Task<T> for asynchronous coroutines, QCoro::Generator<T> for synchronous generators and QCoro::AsyncGenerator<T> for asynchronous generators. Another useful bit of the Coro module is the qCoro() wrapper function that wraps native Qt types into a coroutine-friendly versions supported by QCoro (check the Core , Network and DBus modules of QCoro to see which Qt types are currently supported by QCoro). If you don't want to use any of the Qt types supported by QCoro in your code, but you still want to use C++ coroutines with QCoro, you can simply just link against QCoro::Coro target in your CMakeLists.txt. This will give you all you need to start implementing custom coroutine-native types with Qt and QCoro.","title":"Coro module"},{"location":"reference/coro/asyncgenerator/","text":"QCoro::AsyncGenerator Module Coro Include #include <QCoroAsyncGenerator> CMake target_link_libraries ( myapp QCoro :: Coro ) QMake QT += QCoroCoro template < typename T > class QCoro :: AsyncGenerator AsyncGenerator<T> is fundamentally identical to QCoro::Generator<T> . The only difference is that the value is produced asynchronously. Asynchronous generator is used exactly the same way as synchronous generators, except that the result of AsyncGenerator<T>::begin() must be co_await ed, and incrementing the returned iterator must be co_await ed as well. QCoro :: AsyncGenerator < uint8_t > lottoNumbersGenerator ( int count ) { Hat hat ; // Hat with numbers Hand hand ; // Hand to pull numbers out of the hat for ( int = 0 ; i < count ; ++ i ) { const uint8_t number = co_await hand . pullNumberFrom ( hat ); co_yield number ; // guaranteed to be a winning number } } void winningLottoNumbers () { const auto makeMeRich = lottoNumbersGenerator ( 10 ); // We must co_await begin() to obtain the initial iterator auto winningNumber = co_await makeMeRich . begin (); std :: cout << \"Winning numbers: \" ; while ( winningNumber != makeMeRich . end ()) { std :: cout << * winningNumger ; // And we must co_await increment co_await ++ ( winningNumber ); } } You might be wondering why are we co_await ing AsyncGenerator<T>::begin() and AsyncGeneratorIterator<T>::operator++() , and not just the value (the result of dereferencing the iterator) - it would surely make the code simpler and more intuitive. The simple reason is that we are co_await ing the next iterator (which either holds a value or is past-the-end iterator) rather than the value itself. Once we have the iterator, we must check whether it's valid or not, because paste-the-end iterator is not dereferencable. That's why the AsyncGenerator<T>::begin() and AsyncGeneratorIterator<T>::operator++() operations are asynchronous, rather than AsyncGeneratorIterator<T>::operator*() . QCORO_FOREACH #define QCORO_FOREACH(value, generator) The example in previous chapter shows one example of looping over values produced by an asynchronous generator with a while loop. This is how it would look like with a for loop: auto generator = createGenerator (); for ( auto it = co_await generator . begin (), end = generator . end (); it != end ; co_await ++ it ) { const QString & value = * it ; ... //do something with value } Sadly, it's not possible to use the generator with a ranged-based for loop. While initially the proposal for C++ coroutines did contain for co_await construct, it was removed as the committee was concerned that it was making assumptions about the future interface of asynchronous generators . For that reason, QCoro provides QCORO_FOREACH macro, which is very similar to Q_FOREACH and works exactly like the for-loop in the example above: QCORO_FOREACH ( const QString & value , createGenerator ()) { ... // do something with value }","title":"QCoro::AsyncGenerator&lt;T>"},{"location":"reference/coro/asyncgenerator/#qcoroasyncgenerator","text":"Module Coro Include #include <QCoroAsyncGenerator> CMake target_link_libraries ( myapp QCoro :: Coro ) QMake QT += QCoroCoro template < typename T > class QCoro :: AsyncGenerator AsyncGenerator<T> is fundamentally identical to QCoro::Generator<T> . The only difference is that the value is produced asynchronously. Asynchronous generator is used exactly the same way as synchronous generators, except that the result of AsyncGenerator<T>::begin() must be co_await ed, and incrementing the returned iterator must be co_await ed as well. QCoro :: AsyncGenerator < uint8_t > lottoNumbersGenerator ( int count ) { Hat hat ; // Hat with numbers Hand hand ; // Hand to pull numbers out of the hat for ( int = 0 ; i < count ; ++ i ) { const uint8_t number = co_await hand . pullNumberFrom ( hat ); co_yield number ; // guaranteed to be a winning number } } void winningLottoNumbers () { const auto makeMeRich = lottoNumbersGenerator ( 10 ); // We must co_await begin() to obtain the initial iterator auto winningNumber = co_await makeMeRich . begin (); std :: cout << \"Winning numbers: \" ; while ( winningNumber != makeMeRich . end ()) { std :: cout << * winningNumger ; // And we must co_await increment co_await ++ ( winningNumber ); } } You might be wondering why are we co_await ing AsyncGenerator<T>::begin() and AsyncGeneratorIterator<T>::operator++() , and not just the value (the result of dereferencing the iterator) - it would surely make the code simpler and more intuitive. The simple reason is that we are co_await ing the next iterator (which either holds a value or is past-the-end iterator) rather than the value itself. Once we have the iterator, we must check whether it's valid or not, because paste-the-end iterator is not dereferencable. That's why the AsyncGenerator<T>::begin() and AsyncGeneratorIterator<T>::operator++() operations are asynchronous, rather than AsyncGeneratorIterator<T>::operator*() .","title":"QCoro::AsyncGenerator"},{"location":"reference/coro/asyncgenerator/#qcoro_foreach","text":"#define QCORO_FOREACH(value, generator) The example in previous chapter shows one example of looping over values produced by an asynchronous generator with a while loop. This is how it would look like with a for loop: auto generator = createGenerator (); for ( auto it = co_await generator . begin (), end = generator . end (); it != end ; co_await ++ it ) { const QString & value = * it ; ... //do something with value } Sadly, it's not possible to use the generator with a ranged-based for loop. While initially the proposal for C++ coroutines did contain for co_await construct, it was removed as the committee was concerned that it was making assumptions about the future interface of asynchronous generators . For that reason, QCoro provides QCORO_FOREACH macro, which is very similar to Q_FOREACH and works exactly like the for-loop in the example above: QCORO_FOREACH ( const QString & value , createGenerator ()) { ... // do something with value }","title":"QCORO_FOREACH"},{"location":"reference/coro/coro/","text":"qCoro() Wrapping Qt Types QCoroType qCoro ( QtClass * ); QCoroType qCoro ( QtClass & ); This function is overloaded for all Qt types supported by this library. It accepts either a pointer or a reference to a Qt type, and returns a QCoro type that wraps the Qt type and provides coroutine-friendly API for the type. Some objects have only a single asynchronous event, so it makes sense to make them directly co_await able. An example is QTimer , where only one thing can be co_await ed - the timer timeout. Thus with QCoro, it's possible to simply do this: QTimer timer ; ... co_await timer ; However, some Qt classes have multiple asynchronous operations that the user may want to co_await . For such types, simply co_await ing the class instance doesn't make sense since it's not clear what operation is being co_await ed. For those types, QCoro provides qCoro() function which returns a wrapper that provides coroutine-friendly versions of the asynchronous methods for the given type. Let's take QProcess as an example: one may want to co_await for the program to start or finish. Therefore the type must be wrapped into qCoro() like this: QProcess process ; // Wait for the process to be started co_await qCoro ( process ). start (...); // The process is running now ... ... // Wait for it to finish co_await qCoro ( process ). finished (); // The process is no longer running ... qCoro() is simply overloaded for all the Qt types currently supported by the QCoro library. The function returns a wrapper object (e.g. QCoro::detail::QCoroProcess ) which copies the QProcess API. It doesn't copy the entire API, only the bits that we want to make co_await able. When you call one of those metods (e.g. QCoroProcess::start() ), it returns an awaitable type that calls QProcess::start() , suspends the coroutine and resumes it again when the wrapped QProcess object emits the started() signal. Normally you don't need to concern yourself with anything inside the QCoro::detail namespace, it's mentioned in the previous paragraph simply to explain how the wrapper works.","title":"QCoro::coro()"},{"location":"reference/coro/coro/#qcoro","text":"","title":"qCoro()"},{"location":"reference/coro/coro/#wrapping-qt-types","text":"QCoroType qCoro ( QtClass * ); QCoroType qCoro ( QtClass & ); This function is overloaded for all Qt types supported by this library. It accepts either a pointer or a reference to a Qt type, and returns a QCoro type that wraps the Qt type and provides coroutine-friendly API for the type. Some objects have only a single asynchronous event, so it makes sense to make them directly co_await able. An example is QTimer , where only one thing can be co_await ed - the timer timeout. Thus with QCoro, it's possible to simply do this: QTimer timer ; ... co_await timer ; However, some Qt classes have multiple asynchronous operations that the user may want to co_await . For such types, simply co_await ing the class instance doesn't make sense since it's not clear what operation is being co_await ed. For those types, QCoro provides qCoro() function which returns a wrapper that provides coroutine-friendly versions of the asynchronous methods for the given type. Let's take QProcess as an example: one may want to co_await for the program to start or finish. Therefore the type must be wrapped into qCoro() like this: QProcess process ; // Wait for the process to be started co_await qCoro ( process ). start (...); // The process is running now ... ... // Wait for it to finish co_await qCoro ( process ). finished (); // The process is no longer running ... qCoro() is simply overloaded for all the Qt types currently supported by the QCoro library. The function returns a wrapper object (e.g. QCoro::detail::QCoroProcess ) which copies the QProcess API. It doesn't copy the entire API, only the bits that we want to make co_await able. When you call one of those metods (e.g. QCoroProcess::start() ), it returns an awaitable type that calls QProcess::start() , suspends the coroutine and resumes it again when the wrapped QProcess object emits the started() signal. Normally you don't need to concern yourself with anything inside the QCoro::detail namespace, it's mentioned in the previous paragraph simply to explain how the wrapper works.","title":"Wrapping Qt Types"},{"location":"reference/coro/generator/","text":"QCoro::Generator Module Coro Include #include <QCoroGenerator> CMake target_link_libraries ( myapp QCoro :: Coro ) QMake QT += QCoroCoro template < typename T > class QCoro :: Generator Generator is a coroutine that that yields a single value and then suspends itself, until resumed again. Then it yields another value and suspends again. Generator can be inifinite (the coroutine will never finish and will produce new values for ever until destroyed from the outside) or finite (after generating some amount of values the coroutine finishes). The QCoro::Generator<T> is a template class providing interface for the generator consumer. There is no standard API for generators specified in the C++ standard (as of C++20). The design chosen by QCoro copies the design of cppcoro library, which is for the Generator<T> class to provide begin() and end() methods to obtain iterator- like objects, allowing the generators to be used like containers and providing an interface that is familiar to every C++ programmer. // Simple generator that produces `count` values from 0 to `(count-1)`. QCoro :: Generator < int > iota ( int count ) { for ( int i = 0 ; i < count ; ++ i ) { // Yields a value and suspends the generator. co_yield count ; } } void counter () { // Creates a new initially suspended generator coroutine auto generator = iota ( 10 ); // Resumes the coroutine, obtains first value and returns // an iterator representing the first value. auto it = generator . begin (); // Obtains a past-the-end iterator. const auto end = generator . end (); // Loops until the generator doesn't finish. while ( it != end ) { // Resumes the generator until it co_yields another value. ++ it ; // Reads the current value from the iterator. std :: cout << * it << std :: endl ; } // The code above can be written more consisely using ranged based for-loop for ( const auto value : iota ( 10 )) { std :: count << value << std :: endl ; } } Infinite generators A generator may be inifinite, that is it may never finish and keep producing values whenever queried. A simple naive example might be a generator producing random value whenever resumed. See the next chapter on generator lifetime regarding how to destroy an infinite generator. QCoro :: Generator < quint32 > randomNumberGenerator () { auto * generator = QRandomGenerator :: system (); while ( true ) { // Generates a single random value and suspends. co_yield generator -> generate (); } } void randomInitialize ( QVector < quint32 > & vector ) { // Constructs the generator auto rng = randomNumberGenerator (); // Gets the first tandom value auto rngIt = rng . begin (); // Loops over all values of the vector for ( auto & val : vector ) { // Stores the current random value and generates a next one val = * ( rngIt ++ ); } } // Destroyes the generator coroutine. Generator lifetime The lifetime of the generator coroutine is tight to the lifetime of the associated QCoro::Generator<T> object. The generator coroutine is destroyed when the associated QCoro::Generator<T> object is destroyed, that includes the stack of the coroutine and everything allocated on the stack. It doesn't matter whether the coroutine has already finished or whether it is suspended after yielding a value. When the QCoro::Generator<T> object is destroyed, the stack of the coroutine and all associated state will be destroyed using the regular rules of stack destruction. Therefore, it is stafe to allocate values on generator coroutine stack. However, dynamically allocated memory will not be free'd automatically. Therefore if you need to dynamically allocate memory on heap inside the generator coroutine, you must make sure to either free it before the generator coroutine is suspended, or that it is destroyed when the stack is destroyed, e.g. by using it in std::unique_ptr or QScopeGuard . Memory usage Keep in mind, that that generator coroutine will keep occupying memory even when not used until it finishes or until the associated QCoro::Generator<T> is destroyed.","title":"QCoro::Generator&lt;T>"},{"location":"reference/coro/generator/#qcorogenerator","text":"Module Coro Include #include <QCoroGenerator> CMake target_link_libraries ( myapp QCoro :: Coro ) QMake QT += QCoroCoro template < typename T > class QCoro :: Generator Generator is a coroutine that that yields a single value and then suspends itself, until resumed again. Then it yields another value and suspends again. Generator can be inifinite (the coroutine will never finish and will produce new values for ever until destroyed from the outside) or finite (after generating some amount of values the coroutine finishes). The QCoro::Generator<T> is a template class providing interface for the generator consumer. There is no standard API for generators specified in the C++ standard (as of C++20). The design chosen by QCoro copies the design of cppcoro library, which is for the Generator<T> class to provide begin() and end() methods to obtain iterator- like objects, allowing the generators to be used like containers and providing an interface that is familiar to every C++ programmer. // Simple generator that produces `count` values from 0 to `(count-1)`. QCoro :: Generator < int > iota ( int count ) { for ( int i = 0 ; i < count ; ++ i ) { // Yields a value and suspends the generator. co_yield count ; } } void counter () { // Creates a new initially suspended generator coroutine auto generator = iota ( 10 ); // Resumes the coroutine, obtains first value and returns // an iterator representing the first value. auto it = generator . begin (); // Obtains a past-the-end iterator. const auto end = generator . end (); // Loops until the generator doesn't finish. while ( it != end ) { // Resumes the generator until it co_yields another value. ++ it ; // Reads the current value from the iterator. std :: cout << * it << std :: endl ; } // The code above can be written more consisely using ranged based for-loop for ( const auto value : iota ( 10 )) { std :: count << value << std :: endl ; } }","title":"QCoro::Generator"},{"location":"reference/coro/generator/#infinite-generators","text":"A generator may be inifinite, that is it may never finish and keep producing values whenever queried. A simple naive example might be a generator producing random value whenever resumed. See the next chapter on generator lifetime regarding how to destroy an infinite generator. QCoro :: Generator < quint32 > randomNumberGenerator () { auto * generator = QRandomGenerator :: system (); while ( true ) { // Generates a single random value and suspends. co_yield generator -> generate (); } } void randomInitialize ( QVector < quint32 > & vector ) { // Constructs the generator auto rng = randomNumberGenerator (); // Gets the first tandom value auto rngIt = rng . begin (); // Loops over all values of the vector for ( auto & val : vector ) { // Stores the current random value and generates a next one val = * ( rngIt ++ ); } } // Destroyes the generator coroutine.","title":"Infinite generators"},{"location":"reference/coro/generator/#generator-lifetime","text":"The lifetime of the generator coroutine is tight to the lifetime of the associated QCoro::Generator<T> object. The generator coroutine is destroyed when the associated QCoro::Generator<T> object is destroyed, that includes the stack of the coroutine and everything allocated on the stack. It doesn't matter whether the coroutine has already finished or whether it is suspended after yielding a value. When the QCoro::Generator<T> object is destroyed, the stack of the coroutine and all associated state will be destroyed using the regular rules of stack destruction. Therefore, it is stafe to allocate values on generator coroutine stack. However, dynamically allocated memory will not be free'd automatically. Therefore if you need to dynamically allocate memory on heap inside the generator coroutine, you must make sure to either free it before the generator coroutine is suspended, or that it is destroyed when the stack is destroyed, e.g. by using it in std::unique_ptr or QScopeGuard . Memory usage Keep in mind, that that generator coroutine will keep occupying memory even when not used until it finishes or until the associated QCoro::Generator<T> is destroyed.","title":"Generator lifetime"},{"location":"reference/coro/task/","text":"QCoro::Task Module Coro Include #include <QCoroTask> CMake target_link_libraries ( myapp QCoro :: Coro ) QMake QT += QCoroCoro template < typename T > class QCoro :: Task Any coroutine that wants to co_await one of the types supported by the QCoro library must have return type QCoro::Task<T> , where T is the type of the \"regular\" coroutine return value. There's no need by the user to interact with or construct QCoro::Task manually, the object is constructed automatically by the compiler before the user code is executed. To return a value from a coroutine, use co_return , which will store the result in the Task object and leave the coroutine. QCoro :: Task < QString > getUserName ( UserID userId ) { ... // Obtain a QString by co_awaiting another coroutine const QString result = co_await fetchUserNameFromDb ( userId ); ... // Return the QString from the coroutine as you would from a regular function, // just use `co_return` instead of `return` keyword. co_return result ; } To obtain the result of a coroutine that returns QCoro::Task<T> , the result must be co_await ed. When the coroutine co_return s a result, the result is stored in the Task object and the co_await ing coroutine is resumed. The result is obtained from the returned Task object and returned as a result of the co_await call. QCoro :: Task < void > getUserDetails ( UserID userId ) { ... const QString name = co_await getUserName ( userId ); ... } Exception Propagation When coroutines throws an unhandled exception, the exception is stored in the Task object and is re-thrown from the co_await call in the awaiting coroutine. then() continuation This feature is available since QCoro 0.5.0 Sometimes it's not possible to co_await a coroutine, for example when calling a coroutine from a reimplementation of a virtual function from a 3rd party library, where we cannot change the signature of that function to be a coroutine (e.g. a reimplementation of QAbstractItemModel::data() ). Even in this case, we want to process the result of the coroutine asynchronously, though. For such cases, Task<T> provides a then() member function that allows the caller to provide a custom continuation callback to be invoked when the coroutine finishes. template < typename ThenCallback > requires ( std :: invocable < ThenCallback > || ( ! std :: is_void < T > && std :: invocable < ThenCallback , T > )) Task < R > Task < T >:: then ( ThenCallback callback ); The Task<T>::then() member function has two arguments. The first argument is the continuation that is called when the coroutine finishes. The second argument is optional - it is a callable that gets invoked instead of the continuation when the coroutine throws an exception. The continuation callback must be a callable that accepts either zero arguments (effectively discardin the result of the coroutine), or exactly one argument of type T or type implicitly constructible from T . If the return type of the ThenCallback is void , then the return type of the then() functon is Task<void> . If the return type of the ThenCallback is R or Task<R> , the return type of the then() function is Task<R> . This means that the ThenCallback can be a coroutine as well. Thanks to the return type always being of type Task<R> , it is possible to chain multiple .then() calls, or co_await the result of the entire chain. If the coroutine throws an exception, the exception is re-thrown when the result of the entire continuation is co_await ed. If the result of the continuation is not co_await ed, the exception is silently ignored. If an exception is thrown from the ThenCallback , then the exception is either propagated to the nex chained then() continuation or re-thrown if directly co_await ed. If the result is not co_await ed and no futher then() continuation is chained after the one that has thrown, then the exception is silently ignored. template < typename ThenCallback , typename ErrorCallback > requires ((( std :: is_void_t < T > && std :: invocable < ThenCallback > ) || std :: invocable < ThenCallback , T > ) && std :: invocable < ErrorCallback , const std :: exception &> ) Task < R > Task < T >:: then ( ThenCallback thenCallback , ErrorCallback errorCallback ); An overload of the then() member function which takes an additional callback to be invoked when an exception is thrown from the coroutine. The ErrorCallback must be a callable that takes exactly one argument, which is const std::exception & , holding reference to the exception thrown. An exception thrown from the ErrorCallback will be re-thrown if the entire continuation is co_await ed. If another .then() continuation is chained after the current continuation and has an ErrorCallback , then the ErrorCallback will be invoked. Otherwise, the exception is silently ignored. If an exception is thrown by the non-void coroutine and is handled by the ErrorCallback , then if the resulting continuation is co_await ed, the result will be a default-constructed instance of type R (since the ThenCallback was unable to provide a proper instance of type R ). If R is not default- constructible, the program will not compile. Thus, if returning a non-default-constructible type from a coroutine that may throw an exception, we recommend to wrap the type in std::optional . Examples: QString User::name () { if ( mName . isNull ()) { mApi . fetchUserName (). then ( [ this ]( const QString & name ) { mName = name ; Q_EMIT nameChanged (); }, []( const std :: exception & e ) { mName = QStringLiteral ( \"Failed to fetch name: %1\" ). arg ( e . what ()); Q_EMIT nameChanged (); }); return QStringLiteral ( \"Loading...\" ); } else { return mName ; } } Blocking wait Sometimes it's necessary to wait for a coroutine in a blocking manner - this is especially useful in tests where possibly no event loop is running. QCoro has QCoro::waitFor() function which takes QCoro::Task<T> (that is, result of calling any QCoro-based coroutine) and blocks until the coroutine finishes. If the coroutine has a non-void return value, the value is returned from waitFor(). QCoro :: Task < int > computeAnswer () { std :: this_thread :: sleep_for ( std :: chrono :: year { 7'500'000 }); co_return 42 ; } void nonCoroutineFunction () { // The following line will block as if computeAnswer were not a coroutine. const int answer = QCoro :: waitFor ( computeAnswer ()); std :: cout << \"The answer is: \" << answer << std :: endl ; } Event loops The implementation internally uses a QEventLoop to wait for the coroutine to be completed. This means that a QCoreApplication instance must exist, although it does not need to be executed. Usual warnings about using a nested event loop apply here as well.","title":"QCoro::Task&lt;T>"},{"location":"reference/coro/task/#qcorotask","text":"Module Coro Include #include <QCoroTask> CMake target_link_libraries ( myapp QCoro :: Coro ) QMake QT += QCoroCoro template < typename T > class QCoro :: Task Any coroutine that wants to co_await one of the types supported by the QCoro library must have return type QCoro::Task<T> , where T is the type of the \"regular\" coroutine return value. There's no need by the user to interact with or construct QCoro::Task manually, the object is constructed automatically by the compiler before the user code is executed. To return a value from a coroutine, use co_return , which will store the result in the Task object and leave the coroutine. QCoro :: Task < QString > getUserName ( UserID userId ) { ... // Obtain a QString by co_awaiting another coroutine const QString result = co_await fetchUserNameFromDb ( userId ); ... // Return the QString from the coroutine as you would from a regular function, // just use `co_return` instead of `return` keyword. co_return result ; } To obtain the result of a coroutine that returns QCoro::Task<T> , the result must be co_await ed. When the coroutine co_return s a result, the result is stored in the Task object and the co_await ing coroutine is resumed. The result is obtained from the returned Task object and returned as a result of the co_await call. QCoro :: Task < void > getUserDetails ( UserID userId ) { ... const QString name = co_await getUserName ( userId ); ... } Exception Propagation When coroutines throws an unhandled exception, the exception is stored in the Task object and is re-thrown from the co_await call in the awaiting coroutine.","title":"QCoro::Task"},{"location":"reference/coro/task/#then-continuation","text":"This feature is available since QCoro 0.5.0 Sometimes it's not possible to co_await a coroutine, for example when calling a coroutine from a reimplementation of a virtual function from a 3rd party library, where we cannot change the signature of that function to be a coroutine (e.g. a reimplementation of QAbstractItemModel::data() ). Even in this case, we want to process the result of the coroutine asynchronously, though. For such cases, Task<T> provides a then() member function that allows the caller to provide a custom continuation callback to be invoked when the coroutine finishes. template < typename ThenCallback > requires ( std :: invocable < ThenCallback > || ( ! std :: is_void < T > && std :: invocable < ThenCallback , T > )) Task < R > Task < T >:: then ( ThenCallback callback ); The Task<T>::then() member function has two arguments. The first argument is the continuation that is called when the coroutine finishes. The second argument is optional - it is a callable that gets invoked instead of the continuation when the coroutine throws an exception. The continuation callback must be a callable that accepts either zero arguments (effectively discardin the result of the coroutine), or exactly one argument of type T or type implicitly constructible from T . If the return type of the ThenCallback is void , then the return type of the then() functon is Task<void> . If the return type of the ThenCallback is R or Task<R> , the return type of the then() function is Task<R> . This means that the ThenCallback can be a coroutine as well. Thanks to the return type always being of type Task<R> , it is possible to chain multiple .then() calls, or co_await the result of the entire chain. If the coroutine throws an exception, the exception is re-thrown when the result of the entire continuation is co_await ed. If the result of the continuation is not co_await ed, the exception is silently ignored. If an exception is thrown from the ThenCallback , then the exception is either propagated to the nex chained then() continuation or re-thrown if directly co_await ed. If the result is not co_await ed and no futher then() continuation is chained after the one that has thrown, then the exception is silently ignored. template < typename ThenCallback , typename ErrorCallback > requires ((( std :: is_void_t < T > && std :: invocable < ThenCallback > ) || std :: invocable < ThenCallback , T > ) && std :: invocable < ErrorCallback , const std :: exception &> ) Task < R > Task < T >:: then ( ThenCallback thenCallback , ErrorCallback errorCallback ); An overload of the then() member function which takes an additional callback to be invoked when an exception is thrown from the coroutine. The ErrorCallback must be a callable that takes exactly one argument, which is const std::exception & , holding reference to the exception thrown. An exception thrown from the ErrorCallback will be re-thrown if the entire continuation is co_await ed. If another .then() continuation is chained after the current continuation and has an ErrorCallback , then the ErrorCallback will be invoked. Otherwise, the exception is silently ignored. If an exception is thrown by the non-void coroutine and is handled by the ErrorCallback , then if the resulting continuation is co_await ed, the result will be a default-constructed instance of type R (since the ThenCallback was unable to provide a proper instance of type R ). If R is not default- constructible, the program will not compile. Thus, if returning a non-default-constructible type from a coroutine that may throw an exception, we recommend to wrap the type in std::optional . Examples: QString User::name () { if ( mName . isNull ()) { mApi . fetchUserName (). then ( [ this ]( const QString & name ) { mName = name ; Q_EMIT nameChanged (); }, []( const std :: exception & e ) { mName = QStringLiteral ( \"Failed to fetch name: %1\" ). arg ( e . what ()); Q_EMIT nameChanged (); }); return QStringLiteral ( \"Loading...\" ); } else { return mName ; } }","title":"then() continuation"},{"location":"reference/coro/task/#blocking-wait","text":"Sometimes it's necessary to wait for a coroutine in a blocking manner - this is especially useful in tests where possibly no event loop is running. QCoro has QCoro::waitFor() function which takes QCoro::Task<T> (that is, result of calling any QCoro-based coroutine) and blocks until the coroutine finishes. If the coroutine has a non-void return value, the value is returned from waitFor(). QCoro :: Task < int > computeAnswer () { std :: this_thread :: sleep_for ( std :: chrono :: year { 7'500'000 }); co_return 42 ; } void nonCoroutineFunction () { // The following line will block as if computeAnswer were not a coroutine. const int answer = QCoro :: waitFor ( computeAnswer ()); std :: cout << \"The answer is: \" << answer << std :: endl ; } Event loops The implementation internally uses a QEventLoop to wait for the coroutine to be completed. This means that a QCoreApplication instance must exist, although it does not need to be executed. Usual warnings about using a nested event loop apply here as well.","title":"Blocking wait"},{"location":"reference/dbus/","text":"DBus Module The DBus module contains coroutine-friendly wrapper for QtDBus classes. CMake Usage find_package(QCoro6 COMPONENTS DBus) ... target_link_libraries(my-target QCoro::DBus) QMake Usage QT += QCoroDBus","title":"Index"},{"location":"reference/dbus/#dbus-module","text":"The DBus module contains coroutine-friendly wrapper for QtDBus classes.","title":"DBus Module"},{"location":"reference/dbus/#cmake-usage","text":"find_package(QCoro6 COMPONENTS DBus) ... target_link_libraries(my-target QCoro::DBus)","title":"CMake Usage"},{"location":"reference/dbus/#qmake-usage","text":"QT += QCoroDBus","title":"QMake Usage"},{"location":"reference/dbus/qdbuspendingcall/","text":"QDBusPendingCall Module DBus Include #include <QCoroDBusPendingCall> CMake target_link_libraries ( myapp QCoro :: DBus ) QMake QT += QCoroDBus QDBusPendingCall on its own doesn't have any operation that could be awaited asynchronously, this is usually done through a helper class called QDBusPendingCallWatcher . To simplify the API, QCoro allows to directly co_await completion of the pending call or use a wrapper class QCoroDBusPendingCall . To wrap a QDBusPendingCall into a QCoroDBusPendingCall , use qCoro() : QCoroDBusPendingCall qCoro ( const QDBusPendingCall & ); To await completion of the pending call without the qCoro wrapper, just use the pending call in a co_await expression. The behavior is identical to awaiting on result of QCoroDBusPendingCall::waitForFinished() . QDBusPendingCall call = interface . asyncCall (...); const QDBusReply < ... > reply = co_await pendigCall ; QDBusPendingCall vs. QDBusPendingReply As the Qt documentation for QDBusPendingCall says, you are more likely to use QDBusPendingReply in application code than QDBusPendingCall . QCoro has explicit support for QDBusPendingCall to allow using functions that return QDBusPendingCall directly in co_await expressions without the programmer having to first convert it to QDBusPendingReply . QDBusPendingReply can be constructed from a QDBusMessage , which is a result of awaiting QDBusPendingCall , therefore it's possible to perform both the conversion and awaiting in a single line of code: QDBusPendingReply < ... > reply = co_await iface . asyncCall (...); Note that QDBusAbstractInterface::asyncCall returns a QDBusPendingCall . waitForFinished() Waits until the DBus call is finished. This is equivalent to using QDBusPendingCallWatcher and waiting for it to emit the finished() signal. Returns a QDBusMessage representing the reply to the call. If the call is already finished or has an error, the coroutine will not suspend and the co_await expression will return immediatelly. It is also possible to just directly use a QDBusPendingCall in a co_await expression to await its completion: QDBusPendingCall pendingCall = interface . asyncCall (...); const auto reply = co_await pendingCall ; The above is equivalent to: QDBusPendingCall pendingCall = interface . asyncCall (...); const auto reply = co_await qCoro ( pendingCall ). waitForFinished (); This is a coroutine-friendly equivalent to using QDBusPendingCallWatcher : QDBusPendingCall call = interface . asyncCall (...); QDBusPendingCallWatcher * watcher = new QDBusPendingCallWatcher ( call ); QObject :: connect ( watcher , & QDBusPendingCallWatcher :: finished , this , []( QDBusPendingCallWatcher * watcher ) { watcher -> deleteLater (); const QDBusReply < ... > reply = * watcher ; ... }); Example #include <QCoroDBus> QCoro :: Task < QString > PlayerControl :: nextSong () { // Create a regular QDBusInterface representing the Spotify MPRIS interface QDBusInterface spotifyPlayer { QStringLiteral ( \"org.mpris.MediaPlayer2.spotify\" ), QStringLiteral ( \"/org/mpris/MediaPlayer2\" ), QStringLiteral ( \"org.mpris.MediaPlayer2.Player\" )}; // Call CanGoNext DBus method and co_await reply. During that the current coroutine is suspended. const QDBusReply < bool > canGoNext = co_await spotifyPlayer . asyncCall ( QStringLiteral ( \"CanGoNext\" )); // Response has arrived and coroutine is resumed. If the player can go to the next song, // do another async call to do so. if ( static_cast < bool > ( canGoNext )) { // co_await the call to finish, but throw away the result co_await spotifyPlayer . asyncCall ( QStringLiteral ( \"Next\" )); } // Finally, another async call to retrieve new track metadata. Once again, the coroutine // is suspended while we wait for the result. const QDBusReply < QVariantMap > metadata = co_await spotifyPlayer . asyncCall ( QStringLiteral ( \"Metadata\" )); // Since this function uses co_await, it is in fact a coroutine, so it must use co_return in order // to return our result. By definition, the result of this function can be co_awaited by the caller. co_return static_cast < const QVariantMap &> ( metadata )[ QStringLiteral ( \"xesam:title\" )]. toString (); }","title":"QDBusPendingCall"},{"location":"reference/dbus/qdbuspendingcall/#qdbuspendingcall","text":"Module DBus Include #include <QCoroDBusPendingCall> CMake target_link_libraries ( myapp QCoro :: DBus ) QMake QT += QCoroDBus QDBusPendingCall on its own doesn't have any operation that could be awaited asynchronously, this is usually done through a helper class called QDBusPendingCallWatcher . To simplify the API, QCoro allows to directly co_await completion of the pending call or use a wrapper class QCoroDBusPendingCall . To wrap a QDBusPendingCall into a QCoroDBusPendingCall , use qCoro() : QCoroDBusPendingCall qCoro ( const QDBusPendingCall & ); To await completion of the pending call without the qCoro wrapper, just use the pending call in a co_await expression. The behavior is identical to awaiting on result of QCoroDBusPendingCall::waitForFinished() . QDBusPendingCall call = interface . asyncCall (...); const QDBusReply < ... > reply = co_await pendigCall ; QDBusPendingCall vs. QDBusPendingReply As the Qt documentation for QDBusPendingCall says, you are more likely to use QDBusPendingReply in application code than QDBusPendingCall . QCoro has explicit support for QDBusPendingCall to allow using functions that return QDBusPendingCall directly in co_await expressions without the programmer having to first convert it to QDBusPendingReply . QDBusPendingReply can be constructed from a QDBusMessage , which is a result of awaiting QDBusPendingCall , therefore it's possible to perform both the conversion and awaiting in a single line of code: QDBusPendingReply < ... > reply = co_await iface . asyncCall (...); Note that QDBusAbstractInterface::asyncCall returns a QDBusPendingCall .","title":"QDBusPendingCall"},{"location":"reference/dbus/qdbuspendingcall/#waitforfinished","text":"Waits until the DBus call is finished. This is equivalent to using QDBusPendingCallWatcher and waiting for it to emit the finished() signal. Returns a QDBusMessage representing the reply to the call. If the call is already finished or has an error, the coroutine will not suspend and the co_await expression will return immediatelly. It is also possible to just directly use a QDBusPendingCall in a co_await expression to await its completion: QDBusPendingCall pendingCall = interface . asyncCall (...); const auto reply = co_await pendingCall ; The above is equivalent to: QDBusPendingCall pendingCall = interface . asyncCall (...); const auto reply = co_await qCoro ( pendingCall ). waitForFinished (); This is a coroutine-friendly equivalent to using QDBusPendingCallWatcher : QDBusPendingCall call = interface . asyncCall (...); QDBusPendingCallWatcher * watcher = new QDBusPendingCallWatcher ( call ); QObject :: connect ( watcher , & QDBusPendingCallWatcher :: finished , this , []( QDBusPendingCallWatcher * watcher ) { watcher -> deleteLater (); const QDBusReply < ... > reply = * watcher ; ... });","title":"waitForFinished()"},{"location":"reference/dbus/qdbuspendingcall/#example","text":"#include <QCoroDBus> QCoro :: Task < QString > PlayerControl :: nextSong () { // Create a regular QDBusInterface representing the Spotify MPRIS interface QDBusInterface spotifyPlayer { QStringLiteral ( \"org.mpris.MediaPlayer2.spotify\" ), QStringLiteral ( \"/org/mpris/MediaPlayer2\" ), QStringLiteral ( \"org.mpris.MediaPlayer2.Player\" )}; // Call CanGoNext DBus method and co_await reply. During that the current coroutine is suspended. const QDBusReply < bool > canGoNext = co_await spotifyPlayer . asyncCall ( QStringLiteral ( \"CanGoNext\" )); // Response has arrived and coroutine is resumed. If the player can go to the next song, // do another async call to do so. if ( static_cast < bool > ( canGoNext )) { // co_await the call to finish, but throw away the result co_await spotifyPlayer . asyncCall ( QStringLiteral ( \"Next\" )); } // Finally, another async call to retrieve new track metadata. Once again, the coroutine // is suspended while we wait for the result. const QDBusReply < QVariantMap > metadata = co_await spotifyPlayer . asyncCall ( QStringLiteral ( \"Metadata\" )); // Since this function uses co_await, it is in fact a coroutine, so it must use co_return in order // to return our result. By definition, the result of this function can be co_awaited by the caller. co_return static_cast < const QVariantMap &> ( metadata )[ QStringLiteral ( \"xesam:title\" )]. toString (); }","title":"Example"},{"location":"reference/dbus/qdbuspendingreply/","text":"QDBusPendingReply Module DBus Include #include <QCoroDBusPendingReply> CMake target_link_libraries ( myapp QCoro :: DBus ) QMake QT += QCoroDBus QDBusPendingReply on its own doesn't have any operation that could be awaited asynchronously, this is usually done through a helper class called QDBusPendingCallWatcher . To simplify the API, QCoro allows to directly co_await completion of the pending reply or use a wrapper class QCoroDBusPendingReply . To wrap a QDBusPendingReply into a QCoroDBusPendingReply , use qCoro() : template < typename ... Args > QCoroDBusPendingCall qCoro ( const QDBusPendingReply < Args ... > & ); QDBusPendingReply in Qt5 vs Qt6 QDBusPendingReply in Qt6 is a variadic template, meaning that it can take any amount of template arguments. In Qt5, however, QDBusPendingReply is a template class that accepts only up to 8 paremeters. In QCoro the QCoroDBusPendingReply wrapper is implemented as a variadic template for compatibility with Qt6, but when building against Qt5, the number of template parameters is artificially limited to 8 to mirror the limitation of Qt5 QDBusPendingReply limitation. To await completion of the pending call without the qCoro wrapper, just use the pending call in a co_await expression. The behavior is identical to awaiting on result of QCoroDBusPendingReply::waitForFinished() . QDBusPendingReply < ... > reply = interface . asyncCall (...); co_await reply ; // Now the reply is finished and the result can be retrieved. waitForFinished() Waits until the DBus call is finished. This is equivalent to using QDBusPendingCallWatcher and waiting for it to emit the finished() signal. Returns a QDBusMessage representing the received reply. If the reply is already finished or an error has occurred the coroutine will not suspend and will return a result immediatelly. This is a coroutine-friendly equivalent to using QDBusPendingCallWatcher : QDBusPendingCall call = interface . asyncCall (...); QDBusPendingCallWatcher * watcher = new QDBusPendingCallWatcher ( call ); QObject :: connect ( watcher , & QDBusPendingCallWatcher :: finished , this , []( QDBusPendingCallWatcher * watcher ) { watcher -> deleteLater (); const QDBusPendingReply < ... > reply = * watcher ; ... }); It is also possible to just directly use a QDBusPendingReply in a co_await expression to await its completion: QDBusPendingReply < ... > pendingReply = interface . asyncCall (...); const auto reply = co_await pendingReply ; The above is equivalent to: QDBusPendingReply < ... > pendingReply = interface . asyncCall (...); const auto reply = co_await qCoro ( pendingReply ). waitForFinished (); Example #include <QCoroDBus> QCoro :: Task < QString > PlayerControl :: nextSong () { // Create a regular QDBusInterface representing the Spotify MPRIS interface QDBusInterface spotifyPlayer { QStringLiteral ( \"org.mpris.MediaPlayer2.spotify\" ), QStringLiteral ( \"/org/mpris/MediaPlayer2\" ), QStringLiteral ( \"org.mpris.MediaPlayer2.Player\" )}; // Call CanGoNext DBus method and co_await reply. During that the current coroutine is suspended. const QDBusReply < bool > canGoNext = co_await spotifyPlayer . asyncCall ( QStringLiteral ( \"CanGoNext\" )); // Response has arrived and coroutine is resumed. If the player can go to the next song, // do another async call to do so. if ( static_cast < bool > ( canGoNext )) { // co_await the call to finish, but throw away the result co_await spotifyPlayer . asyncCall ( QStringLiteral ( \"Next\" )); } // Finally, another async call to retrieve new track metadata. Once again, the coroutine // is suspended while we wait for the result. const QDBusReply < QVariantMap > metadata = co_await spotifyPlayer . asyncCall ( QStringLiteral ( \"Metadata\" )); // Since this function uses co_await, it is in fact a coroutine, so it must use co_return in order // to return our result. By definition, the result of this function can be co_awaited by the caller. co_return static_cast < const QVariantMap &> ( metadata )[ QStringLiteral ( \"xesam:title\" )]. toString (); }","title":"QDBusPendingReply"},{"location":"reference/dbus/qdbuspendingreply/#qdbuspendingreply","text":"Module DBus Include #include <QCoroDBusPendingReply> CMake target_link_libraries ( myapp QCoro :: DBus ) QMake QT += QCoroDBus QDBusPendingReply on its own doesn't have any operation that could be awaited asynchronously, this is usually done through a helper class called QDBusPendingCallWatcher . To simplify the API, QCoro allows to directly co_await completion of the pending reply or use a wrapper class QCoroDBusPendingReply . To wrap a QDBusPendingReply into a QCoroDBusPendingReply , use qCoro() : template < typename ... Args > QCoroDBusPendingCall qCoro ( const QDBusPendingReply < Args ... > & ); QDBusPendingReply in Qt5 vs Qt6 QDBusPendingReply in Qt6 is a variadic template, meaning that it can take any amount of template arguments. In Qt5, however, QDBusPendingReply is a template class that accepts only up to 8 paremeters. In QCoro the QCoroDBusPendingReply wrapper is implemented as a variadic template for compatibility with Qt6, but when building against Qt5, the number of template parameters is artificially limited to 8 to mirror the limitation of Qt5 QDBusPendingReply limitation. To await completion of the pending call without the qCoro wrapper, just use the pending call in a co_await expression. The behavior is identical to awaiting on result of QCoroDBusPendingReply::waitForFinished() . QDBusPendingReply < ... > reply = interface . asyncCall (...); co_await reply ; // Now the reply is finished and the result can be retrieved.","title":"QDBusPendingReply"},{"location":"reference/dbus/qdbuspendingreply/#waitforfinished","text":"Waits until the DBus call is finished. This is equivalent to using QDBusPendingCallWatcher and waiting for it to emit the finished() signal. Returns a QDBusMessage representing the received reply. If the reply is already finished or an error has occurred the coroutine will not suspend and will return a result immediatelly. This is a coroutine-friendly equivalent to using QDBusPendingCallWatcher : QDBusPendingCall call = interface . asyncCall (...); QDBusPendingCallWatcher * watcher = new QDBusPendingCallWatcher ( call ); QObject :: connect ( watcher , & QDBusPendingCallWatcher :: finished , this , []( QDBusPendingCallWatcher * watcher ) { watcher -> deleteLater (); const QDBusPendingReply < ... > reply = * watcher ; ... }); It is also possible to just directly use a QDBusPendingReply in a co_await expression to await its completion: QDBusPendingReply < ... > pendingReply = interface . asyncCall (...); const auto reply = co_await pendingReply ; The above is equivalent to: QDBusPendingReply < ... > pendingReply = interface . asyncCall (...); const auto reply = co_await qCoro ( pendingReply ). waitForFinished ();","title":"waitForFinished()"},{"location":"reference/dbus/qdbuspendingreply/#example","text":"#include <QCoroDBus> QCoro :: Task < QString > PlayerControl :: nextSong () { // Create a regular QDBusInterface representing the Spotify MPRIS interface QDBusInterface spotifyPlayer { QStringLiteral ( \"org.mpris.MediaPlayer2.spotify\" ), QStringLiteral ( \"/org/mpris/MediaPlayer2\" ), QStringLiteral ( \"org.mpris.MediaPlayer2.Player\" )}; // Call CanGoNext DBus method and co_await reply. During that the current coroutine is suspended. const QDBusReply < bool > canGoNext = co_await spotifyPlayer . asyncCall ( QStringLiteral ( \"CanGoNext\" )); // Response has arrived and coroutine is resumed. If the player can go to the next song, // do another async call to do so. if ( static_cast < bool > ( canGoNext )) { // co_await the call to finish, but throw away the result co_await spotifyPlayer . asyncCall ( QStringLiteral ( \"Next\" )); } // Finally, another async call to retrieve new track metadata. Once again, the coroutine // is suspended while we wait for the result. const QDBusReply < QVariantMap > metadata = co_await spotifyPlayer . asyncCall ( QStringLiteral ( \"Metadata\" )); // Since this function uses co_await, it is in fact a coroutine, so it must use co_return in order // to return our result. By definition, the result of this function can be co_awaited by the caller. co_return static_cast < const QVariantMap &> ( metadata )[ QStringLiteral ( \"xesam:title\" )]. toString (); }","title":"Example"},{"location":"reference/network/","text":"Network Module The Network module contains coroutine-friendly wrapper for QtNetwork classes. CMake Usage find_package(QCoro6 COMPONENTS Network) ... target_link_libraries(my-target QCoro::Network) QMake Usage QT += QCoroNetwork","title":"Index"},{"location":"reference/network/#network-module","text":"The Network module contains coroutine-friendly wrapper for QtNetwork classes.","title":"Network Module"},{"location":"reference/network/#cmake-usage","text":"find_package(QCoro6 COMPONENTS Network) ... target_link_libraries(my-target QCoro::Network)","title":"CMake Usage"},{"location":"reference/network/#qmake-usage","text":"QT += QCoroNetwork","title":"QMake Usage"},{"location":"reference/network/qabstractsocket/","text":"QAbstractSocket Module Network Include #include <QCoroAbstractSocket> CMake target_link_libraries ( myapp QCoro :: Network ) QMake QT += QCoroNetwork Inherits QCoroIODevice QAbstractSocket is a base class for QTcpSocket and QUdpSocket and has some potentially asynchronous operations. In addition to reading and writing, which are provided by QIODevice baseclass and can be used with coroutines thanks to QCoro's QCoroIODevice it provides asynchronous waiting for connecting to and disconnecting from the server. Since QAbstractSocket doesn't provide the ability to co_await those operations, QCoro provides a wrapper calss QCoroAbstractSocket . To wrap a QAbstractSocket object into the QCoroAbstractSocket wrapper, use qCoro() : QCoroAbstractSocket qCoro ( QAbstractSocket & ); QCoroAbstractSocket qCoro ( QAbstractSocket * ); Same as QAbstractSocket is a subclass of QIODevice , QCoroAbstractSocket subclasses QCoroIODevice , so it also provides the awaitable interface for selected QIODevice functions. See QCoroIODevice documentation for details. waitForConnected() Waits for the socket to connect or until it times out. Returns bool indicating whether connection has been established ( true ) or whether the operation has timed out or another error has occurred ( false ). Returns immediatelly when the socket is already in connected state. If the timeout is -1, the operation will never time out. See documentation for QAbstractSocket::waitForConnected() for details. QCoro :: Task < bool > QCoroAbstractSocket :: waitForConnected ( int timeout_msecs = 30'000 ); QCoro :: Task < bool > QCoroAbstractSocket :: waitForConnected ( std :: chrono :: milliseconds timeout ); waitForDisconnected() Waits for the socket to disconnect from the server or until the operation times out. Returns immediatelly if the socket is not in connected state. If the timeout is -1, the operation will never time out. See documentation for QAbstractSocket::waitForDisconnected() for details. QCoro :: Task < bool > QCoroAbstractSocket :: waitForDisconnected ( timeout_msecs = 30'000 ); QCoro :: Task < bool > QCoroAbstractSocket :: waitForDisconnected ( std :: chrono :: milliseconds timeout ); connectToHost() QCoroAbstractSocket provides an additional method called connectToHost() which is equivalent to calling QAbstractSocket::connectToHost() followed by QAbstractSocket::waitForConnected() . This operation is co_awaitable as well. If the timeout is -1, the operation will never time out. See the documentation for [ QAbstractSocket::connectToHost() ][qtdoc-qabstractsocket-connectToHost] and QAbstractSocket::waitForConnected() for details. QCoro :: Task < bool > QCoroAbstractSocket :: connectToHost ( const QHostAddress & address , quint16 port , QIODevice :: OpenMode openMode = QIODevice :: ReadOnly , std :: chrono :: milliseconds timeout = std :: chrono :: seconds ( 30 )); QCoro :: Task < bool > QCoroAbstractSocket :: connectToHost ( const QString & hostName , quint16 port , QIODevice :: OpenMode openMode = QIODevice :: ReadOnly , QAbstractSocket :: NetworkLayerProtocol protocol = QAbstractSocket :: AnyIPProtocol , std :: chrono :: milliseconds timeout = std :: chrono :: seconds ( 30 )); Examples #include <QCoroTcpSocket> QCoro :: Task < QByteArray > requestDataFromServer ( const QString & hostName ) { QTcpSocket socket ; if ( ! co_await qCoro ( socket ). connectToHost ( hostName )) { qWarning () << \"Failed to connect to the server\" ; co_return QByteArray {}; } socket . write ( \"SEND ME DATA!\" ); QByteArray data ; while ( ! data . endsWith ( \" \\r\\n . \\r\\n \" )) { data += co_await qCoro ( socket ). readAll (); } co_return data ; } `","title":"QAbstractSocket"},{"location":"reference/network/qabstractsocket/#qabstractsocket","text":"Module Network Include #include <QCoroAbstractSocket> CMake target_link_libraries ( myapp QCoro :: Network ) QMake QT += QCoroNetwork Inherits QCoroIODevice QAbstractSocket is a base class for QTcpSocket and QUdpSocket and has some potentially asynchronous operations. In addition to reading and writing, which are provided by QIODevice baseclass and can be used with coroutines thanks to QCoro's QCoroIODevice it provides asynchronous waiting for connecting to and disconnecting from the server. Since QAbstractSocket doesn't provide the ability to co_await those operations, QCoro provides a wrapper calss QCoroAbstractSocket . To wrap a QAbstractSocket object into the QCoroAbstractSocket wrapper, use qCoro() : QCoroAbstractSocket qCoro ( QAbstractSocket & ); QCoroAbstractSocket qCoro ( QAbstractSocket * ); Same as QAbstractSocket is a subclass of QIODevice , QCoroAbstractSocket subclasses QCoroIODevice , so it also provides the awaitable interface for selected QIODevice functions. See QCoroIODevice documentation for details.","title":"QAbstractSocket"},{"location":"reference/network/qabstractsocket/#waitforconnected","text":"Waits for the socket to connect or until it times out. Returns bool indicating whether connection has been established ( true ) or whether the operation has timed out or another error has occurred ( false ). Returns immediatelly when the socket is already in connected state. If the timeout is -1, the operation will never time out. See documentation for QAbstractSocket::waitForConnected() for details. QCoro :: Task < bool > QCoroAbstractSocket :: waitForConnected ( int timeout_msecs = 30'000 ); QCoro :: Task < bool > QCoroAbstractSocket :: waitForConnected ( std :: chrono :: milliseconds timeout );","title":"waitForConnected()"},{"location":"reference/network/qabstractsocket/#waitfordisconnected","text":"Waits for the socket to disconnect from the server or until the operation times out. Returns immediatelly if the socket is not in connected state. If the timeout is -1, the operation will never time out. See documentation for QAbstractSocket::waitForDisconnected() for details. QCoro :: Task < bool > QCoroAbstractSocket :: waitForDisconnected ( timeout_msecs = 30'000 ); QCoro :: Task < bool > QCoroAbstractSocket :: waitForDisconnected ( std :: chrono :: milliseconds timeout );","title":"waitForDisconnected()"},{"location":"reference/network/qabstractsocket/#connecttohost","text":"QCoroAbstractSocket provides an additional method called connectToHost() which is equivalent to calling QAbstractSocket::connectToHost() followed by QAbstractSocket::waitForConnected() . This operation is co_awaitable as well. If the timeout is -1, the operation will never time out. See the documentation for [ QAbstractSocket::connectToHost() ][qtdoc-qabstractsocket-connectToHost] and QAbstractSocket::waitForConnected() for details. QCoro :: Task < bool > QCoroAbstractSocket :: connectToHost ( const QHostAddress & address , quint16 port , QIODevice :: OpenMode openMode = QIODevice :: ReadOnly , std :: chrono :: milliseconds timeout = std :: chrono :: seconds ( 30 )); QCoro :: Task < bool > QCoroAbstractSocket :: connectToHost ( const QString & hostName , quint16 port , QIODevice :: OpenMode openMode = QIODevice :: ReadOnly , QAbstractSocket :: NetworkLayerProtocol protocol = QAbstractSocket :: AnyIPProtocol , std :: chrono :: milliseconds timeout = std :: chrono :: seconds ( 30 ));","title":"connectToHost()"},{"location":"reference/network/qabstractsocket/#examples","text":"#include <QCoroTcpSocket> QCoro :: Task < QByteArray > requestDataFromServer ( const QString & hostName ) { QTcpSocket socket ; if ( ! co_await qCoro ( socket ). connectToHost ( hostName )) { qWarning () << \"Failed to connect to the server\" ; co_return QByteArray {}; } socket . write ( \"SEND ME DATA!\" ); QByteArray data ; while ( ! data . endsWith ( \" \\r\\n . \\r\\n \" )) { data += co_await qCoro ( socket ). readAll (); } co_return data ; } `","title":"Examples"},{"location":"reference/network/qlocalsocket/","text":"QLocalSocket Module Network Include #include <QCoroLocalSocket> CMake target_link_libraries ( myapp QCoro :: Network ) QMake QT += QCoroNetwork Inherits QCoroIODevice QLocalSocket has several potentially asynchronous operations in addition to reading and writing, which are provided by QIODevice baseclass and can be used with coroutines thanks to QCoro's QCoroIODevice . Those operations are connecting to and disconnecting from the server. Since QLocalSocket doesn't provide the ability to co_await those operations, QCoro provides a wrapper calss QCoroLocalSocket . To wrap a QLocalSocket object into the QCoroLocalSocket wrapper, use qCoro() : QCoroLocalSocket qCoro ( QLocalSocket & ); QCoroLocalSocket qCoro ( QLocalSocket * ); Same as QLocalSocket is a subclass of QIODevice , QCoroLocalSocket subclasses QCoroIODevice , so it also provides the awaitable interface for selected QIODevice functions. See QCoroIODevice documentation for details. waitForConnected() Waits for the socket to connect or until it times out. Returns bool indicating whether connection has been established ( true ) or whether the operation has timed out or another error has occurred ( false ). Returns immeditelly if the socket is already in connected state. If the timeout is -1, the operation will never time out. See documentation for QLocalSocket::waitForConnected() for details. QCoro :: Task < bool > QCoroLocalSocket :: waitForConnected ( int timeout_msecs = 30'000 ); QCoro :: Task < bool > QCoroLocalSocket :: waitForConnected ( std :: chrono :: milliseconds timeout ); waitForDisconnected() Waits for the socket to disconnect from the server or until the operation times out. Returns immediatelly if the socket is not in connected state. If the timeout is -1, the operation will never time out. See documentation for QLocalSocket::waitForDisconnected() for details. QCoro :: Task < bool > QCoroLocalSocket :: waitForDisconnected ( timeout_msecs = 30'000 ); QCoro :: Task < bool > QCoroLocalSocket :: waitForDisconnected ( std :: chrono :: milliseconds timeout ); connectToServer() QCoroLocalSocket provides an additional method called connectToServer() which is equivalent to calling QLocalSocket::connectToServer() followed by QLocalSocket::waitForConnected() . This operation is co_awaitable as well. If the timeout is -1, the operation will never time out. See the documentation for QLocalSocket::connectToServer() and QLocalSocket::waitForConnected() for details. QCoro :: Task < bool > QCoroLocalSocket :: connectToServer ( QIODevice :: OpenMode openMode = QIODevice :: ReadOnly , std :: chrono :: milliseconds timeout = std :: chrono :: seconds ( 30 )); QCoro :: Taks < bool > QCoroLocalSocket :: connectToServer ( const QString & name , QIODevice :: OpenMode openMode = QIODevice :: ReadOnly , std :: chrono :: milliseconds timeout = std :: chrono :: seconds ( 30 )); Examples QCoro :: Task < QByteArray > requestDataFromServer ( const QString & serverName ) { QLocalSocket socket ; if ( ! co_await qCoro ( socket ). connectToServer ( serverName )) { qWarning () << \"Failed to connect to the server\" ; co_return QByteArray {}; } socket . write ( \"SEND ME DATA!\" ); QByteArray data ; while ( ! data . endsWith ( \" \\r\\n . \\r\\n \" )) { data += co_await qCoro ( socket ). readAll (); } co_return data ; }","title":"QLocalSocket"},{"location":"reference/network/qlocalsocket/#qlocalsocket","text":"Module Network Include #include <QCoroLocalSocket> CMake target_link_libraries ( myapp QCoro :: Network ) QMake QT += QCoroNetwork Inherits QCoroIODevice QLocalSocket has several potentially asynchronous operations in addition to reading and writing, which are provided by QIODevice baseclass and can be used with coroutines thanks to QCoro's QCoroIODevice . Those operations are connecting to and disconnecting from the server. Since QLocalSocket doesn't provide the ability to co_await those operations, QCoro provides a wrapper calss QCoroLocalSocket . To wrap a QLocalSocket object into the QCoroLocalSocket wrapper, use qCoro() : QCoroLocalSocket qCoro ( QLocalSocket & ); QCoroLocalSocket qCoro ( QLocalSocket * ); Same as QLocalSocket is a subclass of QIODevice , QCoroLocalSocket subclasses QCoroIODevice , so it also provides the awaitable interface for selected QIODevice functions. See QCoroIODevice documentation for details.","title":"QLocalSocket"},{"location":"reference/network/qlocalsocket/#waitforconnected","text":"Waits for the socket to connect or until it times out. Returns bool indicating whether connection has been established ( true ) or whether the operation has timed out or another error has occurred ( false ). Returns immeditelly if the socket is already in connected state. If the timeout is -1, the operation will never time out. See documentation for QLocalSocket::waitForConnected() for details. QCoro :: Task < bool > QCoroLocalSocket :: waitForConnected ( int timeout_msecs = 30'000 ); QCoro :: Task < bool > QCoroLocalSocket :: waitForConnected ( std :: chrono :: milliseconds timeout );","title":"waitForConnected()"},{"location":"reference/network/qlocalsocket/#waitfordisconnected","text":"Waits for the socket to disconnect from the server or until the operation times out. Returns immediatelly if the socket is not in connected state. If the timeout is -1, the operation will never time out. See documentation for QLocalSocket::waitForDisconnected() for details. QCoro :: Task < bool > QCoroLocalSocket :: waitForDisconnected ( timeout_msecs = 30'000 ); QCoro :: Task < bool > QCoroLocalSocket :: waitForDisconnected ( std :: chrono :: milliseconds timeout );","title":"waitForDisconnected()"},{"location":"reference/network/qlocalsocket/#connecttoserver","text":"QCoroLocalSocket provides an additional method called connectToServer() which is equivalent to calling QLocalSocket::connectToServer() followed by QLocalSocket::waitForConnected() . This operation is co_awaitable as well. If the timeout is -1, the operation will never time out. See the documentation for QLocalSocket::connectToServer() and QLocalSocket::waitForConnected() for details. QCoro :: Task < bool > QCoroLocalSocket :: connectToServer ( QIODevice :: OpenMode openMode = QIODevice :: ReadOnly , std :: chrono :: milliseconds timeout = std :: chrono :: seconds ( 30 )); QCoro :: Taks < bool > QCoroLocalSocket :: connectToServer ( const QString & name , QIODevice :: OpenMode openMode = QIODevice :: ReadOnly , std :: chrono :: milliseconds timeout = std :: chrono :: seconds ( 30 ));","title":"connectToServer()"},{"location":"reference/network/qlocalsocket/#examples","text":"QCoro :: Task < QByteArray > requestDataFromServer ( const QString & serverName ) { QLocalSocket socket ; if ( ! co_await qCoro ( socket ). connectToServer ( serverName )) { qWarning () << \"Failed to connect to the server\" ; co_return QByteArray {}; } socket . write ( \"SEND ME DATA!\" ); QByteArray data ; while ( ! data . endsWith ( \" \\r\\n . \\r\\n \" )) { data += co_await qCoro ( socket ). readAll (); } co_return data ; }","title":"Examples"},{"location":"reference/network/qnetworkreply/","text":"QNetworkReply Module Network Include #include <QCoroNetworkReply> CMake target_link_libraries ( myapp QCoro :: Network ) QMake QT += QCoroNetwork Inherits QCoroIODevice QNetworkReply has two asynchronous aspects: one is waiting for the reply to finish, and one for reading the response data as they arrive. QCoro supports both. QNetworkReply is a subclass of QIODevice , so you can leverage all the features of QCoroIODevice to asynchronously read data from the underlying QIODevice using coroutines. To wait for the reply to finish, one can simply co_await the reply object: QNetworkAccessManager nam ; auto * reply = co_await nam . get ( request ); The QCoro frameworks allows co_await ing on QNetworkReply objects. The co-awaiting coroutine is suspended, until QNetworkReply::finished() signal is emitted. To make it work, include QCoroNetworkReply in your implementation. #include <QCoroNetworkReply> QCoro :: Task <> MyClass :: fetchData () { // Creates QNetworkAccessManager on stack QNetworkAccessManager nam ; // Calls QNetworkAccessManager::get() and co_awaits on the returned QNetworkReply* // until it finishes. The current coroutine is suspended until that. auto * reply = co_await nam . get ( QUrl { QStringLiteral ( \"https://.../api/fetch\" )}); // When the reply finishes, the coroutine is resumed and we can access the reply content. const auto data = reply -> readAll (); // Raise your hand if you never forgot to delete a QNetworkReply... delete reply ; doSomethingWithData ( data ); // Extra bonus: the QNetworkAccessManager is destroyed automatically, since it's on stack. }","title":"QNetworkReply"},{"location":"reference/network/qnetworkreply/#qnetworkreply","text":"Module Network Include #include <QCoroNetworkReply> CMake target_link_libraries ( myapp QCoro :: Network ) QMake QT += QCoroNetwork Inherits QCoroIODevice QNetworkReply has two asynchronous aspects: one is waiting for the reply to finish, and one for reading the response data as they arrive. QCoro supports both. QNetworkReply is a subclass of QIODevice , so you can leverage all the features of QCoroIODevice to asynchronously read data from the underlying QIODevice using coroutines. To wait for the reply to finish, one can simply co_await the reply object: QNetworkAccessManager nam ; auto * reply = co_await nam . get ( request ); The QCoro frameworks allows co_await ing on QNetworkReply objects. The co-awaiting coroutine is suspended, until QNetworkReply::finished() signal is emitted. To make it work, include QCoroNetworkReply in your implementation. #include <QCoroNetworkReply> QCoro :: Task <> MyClass :: fetchData () { // Creates QNetworkAccessManager on stack QNetworkAccessManager nam ; // Calls QNetworkAccessManager::get() and co_awaits on the returned QNetworkReply* // until it finishes. The current coroutine is suspended until that. auto * reply = co_await nam . get ( QUrl { QStringLiteral ( \"https://.../api/fetch\" )}); // When the reply finishes, the coroutine is resumed and we can access the reply content. const auto data = reply -> readAll (); // Raise your hand if you never forgot to delete a QNetworkReply... delete reply ; doSomethingWithData ( data ); // Extra bonus: the QNetworkAccessManager is destroyed automatically, since it's on stack. }","title":"QNetworkReply"},{"location":"reference/network/qtcpserver/","text":"QTcpServer Module Network Include #include <QCoroTcpServer> CMake target_link_libraries ( myapp QCoro :: Network ) QMake QT += QCoroNetwork QTcpServer really only has one asynchronous operation worth co_await ing, and that's waitForNewConnection() . Since QTcpServer doesn't provide the ability to co_await those operations, QCoro provides a wrapper class QCoroTcpServer . To wrap a QTcpServer object into the QCoroTcpServer wrapper, use qCoro() : QCoroTcpServer qCoro ( QTcpServer & ); QCoroTcpServer qCoro ( QTcpServer * ); waitForNewConnection() Waits until a new incoming connection is available or until it times out. Returns pointer to QTcpSocket or nullptr if the operation timed out or another error has occured. If the timeout is -1 the operation will never time out. See documentation for QTcpServer::waitForNewConnection() for details. QCoro :: Task < QTcpSocket *> QCoroTcpServer :: waitForNewConnection ( int timeout_msecs = 30'000 ); QCoro :: Task < QTcpSocket *> QCoroTcpServer :: waitForNewConnection ( std :: chrono :: milliseconds timeout ); Examples #include <QCoroTcpServer> QCoro :: Task <> runServer ( uint16_t port ) { QTcpServer server ; server . listen ( QHostAddress :: LocalHost , port ); while ( server . isListening ()) { auto * socket = co_await qCoro ( server ). waitForNewConnection ( 10 s ); if ( socket != nullptr ) { newClientConnection ( socket ); } } }","title":"QTcpServer"},{"location":"reference/network/qtcpserver/#qtcpserver","text":"Module Network Include #include <QCoroTcpServer> CMake target_link_libraries ( myapp QCoro :: Network ) QMake QT += QCoroNetwork QTcpServer really only has one asynchronous operation worth co_await ing, and that's waitForNewConnection() . Since QTcpServer doesn't provide the ability to co_await those operations, QCoro provides a wrapper class QCoroTcpServer . To wrap a QTcpServer object into the QCoroTcpServer wrapper, use qCoro() : QCoroTcpServer qCoro ( QTcpServer & ); QCoroTcpServer qCoro ( QTcpServer * );","title":"QTcpServer"},{"location":"reference/network/qtcpserver/#waitfornewconnection","text":"Waits until a new incoming connection is available or until it times out. Returns pointer to QTcpSocket or nullptr if the operation timed out or another error has occured. If the timeout is -1 the operation will never time out. See documentation for QTcpServer::waitForNewConnection() for details. QCoro :: Task < QTcpSocket *> QCoroTcpServer :: waitForNewConnection ( int timeout_msecs = 30'000 ); QCoro :: Task < QTcpSocket *> QCoroTcpServer :: waitForNewConnection ( std :: chrono :: milliseconds timeout );","title":"waitForNewConnection()"},{"location":"reference/network/qtcpserver/#examples","text":"#include <QCoroTcpServer> QCoro :: Task <> runServer ( uint16_t port ) { QTcpServer server ; server . listen ( QHostAddress :: LocalHost , port ); while ( server . isListening ()) { auto * socket = co_await qCoro ( server ). waitForNewConnection ( 10 s ); if ( socket != nullptr ) { newClientConnection ( socket ); } } }","title":"Examples"},{"location":"reference/websockets/","text":"WebSockets Module The WebSockets module contains coroutine-friendly wrapper for QtWebSockets classes. CMake Usage find_package(QCoro6 COMPONENTS WebSockets) ... target_link_libraries(my-target QCoro::WebSockets) QMake Usage QT += QCoroWebSockets","title":"Index"},{"location":"reference/websockets/#websockets-module","text":"The WebSockets module contains coroutine-friendly wrapper for QtWebSockets classes.","title":"WebSockets Module"},{"location":"reference/websockets/#cmake-usage","text":"find_package(QCoro6 COMPONENTS WebSockets) ... target_link_libraries(my-target QCoro::WebSockets)","title":"CMake Usage"},{"location":"reference/websockets/#qmake-usage","text":"QT += QCoroWebSockets","title":"QMake Usage"},{"location":"reference/websockets/qwebsocket/","text":"QWebSocket Module WebSockets Include #include <QCoroWebSocket> CMake target_link_libraries ( myapp QCoro :: WebSockets ) QMake QT += QCoroWebSockets QWebSocket provides a client socket to connect to a WebSocket server, which several asynchronous operations that could be used as coroutines. The QCoroWebSocket wrapper provides exactly this. Use qCoro() to wrap an existing instance of QWebSocket to become QCoroWebSocket : QCoroWebSocket qCoro ( QWebSocket & ); QCoroWebSocket qCoro ( QWebSocket * ); open() Opens connection to the WebSocket server and waits until the connection is established, or a timeout occurs. Resolves to true when the connection was successfully established, or false if the process has timed out. If the timeout is -1 , the operation will never time out. See documentation for QWebSocket::open(const QUrl &) and QWebSocket::open(const QNetworkRequest &) for details. QCoro :: Task < bool > QCoroWebSocket :: open ( const QUrl & url , std :: chrono :: milliseconds timeout ); QCoro :: Task < bool > QCoroWebSocket :: open ( const QNetworkRequest & request , std :: chrono :: milliseconds timeout ); ping() Sends the given payload to the server and waits for response. Returns the roundtrip time elapsed, or empty value if the operation has timed out. If the timeout is set to -1 , the operation will never time out. See documentation for QWebSocket::ping() for details. QCoro :: Task < std :: optional < std :: chrono :: milliseconds >> ping ( const QByteArray & payload , std :: chrono :: milliseconds timeout ); binaryFrames() Returns an asynchronous generator that will yield frame data whenever they arrive. More specifically, the generator will yield a tuple of QByteArray containing the frame data, and a boolean value, indicating whether this is the last frame of a message, allowing to receive large messages in smaller frame-sized chunks. Note that the generator will never terminate, unless the socket is disconnected or unless the time elapsed between frames gets over the specified timeout . If the timeout is -1 , the generator will wait for new frames indefinitely. See documentation for the [ QWebSocket::binaryFrameReceived() ][qtdoc-qwebsocket-binary-frame-received] signal for details. QCoro :: AsyncGenerator < std :: tuple < QByteArray , bool >> QCoroWebSocket :: binaryFrames ( std :: chrono :: milliseconds timeout ); Why generator instead of simply co_awaiting next frame? It's logical to ask why does this function return a generator, rather than simply returning the received frame, the user would then go on to co_await the next frame etc. Unlike e.g. QIODevice -based classes, the QWebSocket is not buffered, that is any frame that arrives when no-one is connected to the binaryFrameReceived() signal is simply dropped and cannot be retrieved later. Therefore we need to use a generator API, which will buffer all received frames for as long as the generator object exists and provide them through the familiar iterator-like interface. Here's an example coroutine that assembles messages from incoming frames and emits a singal whenever a full message is assembled (don't use this in real code, use the binaryMessages() coroutine to receive complete messages). QCoro :: Task <> MessageReceived :: receive () { QByteArray message ; QCORO_FOREACH ( const auto & [ frame , isLast ], qCoro ( mWebSocket ). binaryFrames ()) { message . append ( frame ); if ( isLast ) { Q_EMIT messageAssembled ( message ); message . clear (); } } qDebug () << \"Socket disconnected!\" ; } textFrames() Behaves exactly like binaryFrames() , except that it expects the frame to contain text data. QCoro :: AsyncGenerator < std :: tuple < QString , bool >> QCoroWebSocket :: textFrames ( std :: chrono :: milliseconds timeout ); binaryMessages() Returns an asynchronous generator that will yield a binary message whenever it arrives. Note that the generator will never terminate, unless the socket is disconnected or unless the time elapsed between frames gets over the specified timeout . If the timeout is -1 , the generator will wait for new frames indefinitely. See documentation for the [ QWebSocket::binaryMessageReceived() ][qtdoc-qwebsocket-binary-message-received] signal for details. QCoro :: AsyncGenerator < QByteArray > QCoroWebSocket :: binaryMessages ( std :: chrono :: milliseconds timeout ); textMessages() Behaves exactly like binaryMessages() , except that it expects the message to be text message. QCoro :: AsyncGenerator < QString > QCoroWebSocket :: textMessage ( std :: chrono :: milliseconds timeout );","title":"QWebSocket"},{"location":"reference/websockets/qwebsocket/#qwebsocket","text":"Module WebSockets Include #include <QCoroWebSocket> CMake target_link_libraries ( myapp QCoro :: WebSockets ) QMake QT += QCoroWebSockets QWebSocket provides a client socket to connect to a WebSocket server, which several asynchronous operations that could be used as coroutines. The QCoroWebSocket wrapper provides exactly this. Use qCoro() to wrap an existing instance of QWebSocket to become QCoroWebSocket : QCoroWebSocket qCoro ( QWebSocket & ); QCoroWebSocket qCoro ( QWebSocket * );","title":"QWebSocket"},{"location":"reference/websockets/qwebsocket/#open","text":"Opens connection to the WebSocket server and waits until the connection is established, or a timeout occurs. Resolves to true when the connection was successfully established, or false if the process has timed out. If the timeout is -1 , the operation will never time out. See documentation for QWebSocket::open(const QUrl &) and QWebSocket::open(const QNetworkRequest &) for details. QCoro :: Task < bool > QCoroWebSocket :: open ( const QUrl & url , std :: chrono :: milliseconds timeout ); QCoro :: Task < bool > QCoroWebSocket :: open ( const QNetworkRequest & request , std :: chrono :: milliseconds timeout );","title":"open()"},{"location":"reference/websockets/qwebsocket/#ping","text":"Sends the given payload to the server and waits for response. Returns the roundtrip time elapsed, or empty value if the operation has timed out. If the timeout is set to -1 , the operation will never time out. See documentation for QWebSocket::ping() for details. QCoro :: Task < std :: optional < std :: chrono :: milliseconds >> ping ( const QByteArray & payload , std :: chrono :: milliseconds timeout );","title":"ping()"},{"location":"reference/websockets/qwebsocket/#binaryframes","text":"Returns an asynchronous generator that will yield frame data whenever they arrive. More specifically, the generator will yield a tuple of QByteArray containing the frame data, and a boolean value, indicating whether this is the last frame of a message, allowing to receive large messages in smaller frame-sized chunks. Note that the generator will never terminate, unless the socket is disconnected or unless the time elapsed between frames gets over the specified timeout . If the timeout is -1 , the generator will wait for new frames indefinitely. See documentation for the [ QWebSocket::binaryFrameReceived() ][qtdoc-qwebsocket-binary-frame-received] signal for details. QCoro :: AsyncGenerator < std :: tuple < QByteArray , bool >> QCoroWebSocket :: binaryFrames ( std :: chrono :: milliseconds timeout ); Why generator instead of simply co_awaiting next frame? It's logical to ask why does this function return a generator, rather than simply returning the received frame, the user would then go on to co_await the next frame etc. Unlike e.g. QIODevice -based classes, the QWebSocket is not buffered, that is any frame that arrives when no-one is connected to the binaryFrameReceived() signal is simply dropped and cannot be retrieved later. Therefore we need to use a generator API, which will buffer all received frames for as long as the generator object exists and provide them through the familiar iterator-like interface. Here's an example coroutine that assembles messages from incoming frames and emits a singal whenever a full message is assembled (don't use this in real code, use the binaryMessages() coroutine to receive complete messages). QCoro :: Task <> MessageReceived :: receive () { QByteArray message ; QCORO_FOREACH ( const auto & [ frame , isLast ], qCoro ( mWebSocket ). binaryFrames ()) { message . append ( frame ); if ( isLast ) { Q_EMIT messageAssembled ( message ); message . clear (); } } qDebug () << \"Socket disconnected!\" ; }","title":"binaryFrames()"},{"location":"reference/websockets/qwebsocket/#textframes","text":"Behaves exactly like binaryFrames() , except that it expects the frame to contain text data. QCoro :: AsyncGenerator < std :: tuple < QString , bool >> QCoroWebSocket :: textFrames ( std :: chrono :: milliseconds timeout );","title":"textFrames()"},{"location":"reference/websockets/qwebsocket/#binarymessages","text":"Returns an asynchronous generator that will yield a binary message whenever it arrives. Note that the generator will never terminate, unless the socket is disconnected or unless the time elapsed between frames gets over the specified timeout . If the timeout is -1 , the generator will wait for new frames indefinitely. See documentation for the [ QWebSocket::binaryMessageReceived() ][qtdoc-qwebsocket-binary-message-received] signal for details. QCoro :: AsyncGenerator < QByteArray > QCoroWebSocket :: binaryMessages ( std :: chrono :: milliseconds timeout );","title":"binaryMessages()"},{"location":"reference/websockets/qwebsocket/#textmessages","text":"Behaves exactly like binaryMessages() , except that it expects the message to be text message. QCoro :: AsyncGenerator < QString > QCoroWebSocket :: textMessage ( std :: chrono :: milliseconds timeout );","title":"textMessages()"},{"location":"reference/websockets/qwebsocketserver/","text":"QWebSocketServer Module WebSockets Include #include <QCoroWebSocketServer> CMake target_link_libraries ( myapp QCoro :: WebSockets ) QMake QT += QCoroWebSockets QCoro provides a wrapper for the QWebSocketServer class which allows user to asynchronously co_await incoming connections. To wrap a QWebSocketServer instance, use the qCoro() overload from the QCoroWebSocketServer include header. QCoroWebSocketServer qCoro ( QWebSocketServer & ); QCoroWebSocketServer qCoro ( QWebSocketServer * ); nextPendingConnection() Suspends the awaiter until a new incoming connection becomes available or until the specified timeout. If the specified timeout is -1 , the operation will never time out. Returns a pointer to QWebSocket representing the new connection, or a null pointer if the operation times out, the server is not listen() ining for incoming connections. QCoro :: Task < QWebSocket *> QCoroWebSocketServer :: nextPendingConnection ( std :: chrono :: milliseconds timeout ); Note that pauseAccepting() doesn't resume any awaiting coroutines. QCoro :: Task <> listen ( QWebSocketServer * server ) { server -> listen (); while ( auto socket = std :: unique_ptr < QWebSocket > ( co_await qCoro ( server ). nextPendingConnection ()); socket != nullptr ) { handleConnection ( std :: move ( socket )); } }","title":"QWebSocketServer"},{"location":"reference/websockets/qwebsocketserver/#qwebsocketserver","text":"Module WebSockets Include #include <QCoroWebSocketServer> CMake target_link_libraries ( myapp QCoro :: WebSockets ) QMake QT += QCoroWebSockets QCoro provides a wrapper for the QWebSocketServer class which allows user to asynchronously co_await incoming connections. To wrap a QWebSocketServer instance, use the qCoro() overload from the QCoroWebSocketServer include header. QCoroWebSocketServer qCoro ( QWebSocketServer & ); QCoroWebSocketServer qCoro ( QWebSocketServer * );","title":"QWebSocketServer"},{"location":"reference/websockets/qwebsocketserver/#nextpendingconnection","text":"Suspends the awaiter until a new incoming connection becomes available or until the specified timeout. If the specified timeout is -1 , the operation will never time out. Returns a pointer to QWebSocket representing the new connection, or a null pointer if the operation times out, the server is not listen() ining for incoming connections. QCoro :: Task < QWebSocket *> QCoroWebSocketServer :: nextPendingConnection ( std :: chrono :: milliseconds timeout ); Note that pauseAccepting() doesn't resume any awaiting coroutines. QCoro :: Task <> listen ( QWebSocketServer * server ) { server -> listen (); while ( auto socket = std :: unique_ptr < QWebSocket > ( co_await qCoro ( server ). nextPendingConnection ()); socket != nullptr ) { handleConnection ( std :: move ( socket )); } }","title":"nextPendingConnection()"}]}